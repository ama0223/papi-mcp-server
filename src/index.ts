
// Generated by openapi-to-mcp-generator for segment-public-api v58.14.0
// Source OpenAPI spec: public-api-spec.json
// Generation date: 2025-08-19T16:16:57.379Z

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import express from 'express';
import bodyParser from 'body-parser';

// Import Schemas and Types from /types subpath with .js extension
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  type Tool,
  type CallToolResult,
  type CallToolRequest // Added type for the request parameter
} from "@modelcontextprotocol/sdk/types.js";

// Zod for runtime validation
import { z, ZodError } from 'zod';
// Library to convert JSON Schema to Zod schema string at runtime
import { jsonSchemaToZod } from 'json-schema-to-zod';

// Define JsonObject locally as a utility type
type JsonObject = Record<string, any>;

import axios, { type AxiosRequestConfig, type AxiosError } from 'axios';

// --- Server Configuration ---
const SERVER_NAME = "segment-public-api";
const SERVER_VERSION = "58.14.0";
const API_BASE_URL = "https://api.segmentapis.com";

// Create an axios interceptor with default configuration
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Accept': 'application/json',
    'Authorization': `Bearer ${process.env.SEGMENT_API_TOKEN}`
  }
});

//Request interceptor for logging
apiClient.interceptors.request.use((config) => {
  console.error(`Executing API call: ${config.method?.toUpperCase()} ${config.url}`);
  return config;
});

// --- Server Instance ---
const mcpServer = new Server(
  {
    name: SERVER_NAME,
    version: SERVER_VERSION
  },
  {
    capabilities: {
      tools: {}
    }
  }
);

// --- Tool Definitions (for ListTools response) ---
// Corrected: Use Tool[] type
const toolsList: Tool[] = [

  // Tool: addActivationToAudience (POST /spaces/{spaceId}/audiences/{audienceId}/{connectionId}/activations)
  {
    name: "addActivationToAudience",
    description: `Creates Activation.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Activation Created\` event in the [audit trail](/tag/Audit-Trail).


The rate limit for this endpoint is 10 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "audienceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "connectionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "audienceId",
            "connectionId",
            "requestBody"
        ]
    }
  },
  // Tool: addConnectionFromSourceToWarehouse (POST /warehouses/{warehouseId}/connected-sources/{sourceId})
  {
    name: "addConnectionFromSourceToWarehouse",
    description: `Connects a Source to a Warehouse.



• When called, this endpoint may generate the \`Storage Destination Modified\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "warehouseId",
            "sourceId"
        ]
    }
  },
  // Tool: removeSourceConnectionFromWarehouse (DELETE /warehouses/{warehouseId}/connected-sources/{sourceId})
  {
    name: "removeSourceConnectionFromWarehouse",
    description: `Disconnects a Source from a Warehouse.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "warehouseId",
            "sourceId"
        ]
    }
  },
  // Tool: addDestinationToAudience (POST /spaces/{spaceId}/audiences/{audienceId}/destinations)
  {
    name: "addDestinationToAudience",
    description: `Adds a Destination to an Audience.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Destination Added into Audience\` event in the [audit trail](/tag/Audit-Trail).`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "audienceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "audienceId",
            "requestBody"
        ]
    }
  },
  // Tool: replaceLabelsInSource (PUT /sources/{sourceId}/labels)
  {
    name: "replaceLabelsInSource",
    description: `Replaces all labels in a Source.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Replaces all labels in a Source with a list of new labels.",
                "title": "ReplaceLabelsInSourceV1Input",
                "type": "object",
                "properties": {
                    "labels": {
                        "description": "The list of labels to replace in the Source.",
                        "type": "array",
                        "items": {
                            "description": "A label lets Workspace owners assign permissions to users, and grant these users access to groups.\n\nA Workspace owner may use labels to grant users access to groups of resources.\n\nWhen you add a label to a Source or Personas Spaces, any users granted access to that label gain access to those\nresources.\n\nAll Workspaces include labels for Dev (development) and Prod (production) environments. On top of those, Free and\nTeam plan customers may create up to five labels.\n\nCustomers with the Enterprise pricing package may create an unlimited number of labels.",
                            "title": "LabelV1",
                            "type": "object",
                            "properties": {
                                "key": {
                                    "description": "The key that represents the name of this label.",
                                    "type": "string",
                                    "title": "key"
                                },
                                "value": {
                                    "description": "The value associated with the key of this label.",
                                    "type": "string",
                                    "title": "value"
                                },
                                "description": {
                                    "description": "An optional description of the purpose of this label.",
                                    "type": "string",
                                    "title": "description"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "key",
                                "value"
                            ]
                        },
                        "title": "labels"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "labels"
                ]
            }
        },
        "required": [
            "sourceId",
            "requestBody"
        ]
    }
  },
  // Tool: addLabelsToSource (POST /sources/{sourceId}/labels)
  {
    name: "addLabelsToSource",
    description: `Adds an existing label to a Source.



• When called, this endpoint may generate the \`Source Modified\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Applies an existing label to an existing Source.",
                "title": "AddLabelsToSourceV1Input",
                "type": "object",
                "properties": {
                    "labels": {
                        "description": "The labels to associate with a Source.",
                        "type": "array",
                        "items": {
                            "description": "A label lets Workspace owners assign permissions to users, and grant these users access to groups.\n\nA Workspace owner may use labels to grant users access to groups of resources.\n\nWhen you add a label to a Source or Personas Spaces, any users granted access to that label gain access to those\nresources.\n\nAll Workspaces include labels for Dev (development) and Prod (production) environments. On top of those, Free and\nTeam plan customers may create up to five labels.\n\nCustomers with the Enterprise pricing package may create an unlimited number of labels.",
                            "title": "LabelV1",
                            "type": "object",
                            "properties": {
                                "key": {
                                    "description": "The key that represents the name of this label.",
                                    "type": "string",
                                    "title": "key"
                                },
                                "value": {
                                    "description": "The value associated with the key of this label.",
                                    "type": "string",
                                    "title": "value"
                                },
                                "description": {
                                    "description": "An optional description of the purpose of this label.",
                                    "type": "string",
                                    "title": "description"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "key",
                                "value"
                            ]
                        },
                        "title": "labels"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "labels"
                ]
            }
        },
        "required": [
            "sourceId",
            "requestBody"
        ]
    }
  },
  // Tool: replacePermissionsForUser (PUT /users/{userId}/permissions)
  {
    name: "replacePermissionsForUser",
    description: `Updates the list of access permissions for a user.



• When called, this endpoint may generate the \`Policy Deleted\` event in the [audit trail](/tag/Audit-Trail).
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates the list of permissions for a user.",
                "title": "ReplacePermissionsForUserV1Input",
                "type": "object",
                "properties": {
                    "permissions": {
                        "description": "The permissions to add.",
                        "type": "array",
                        "items": {
                            "description": "The input for a permission, associated with a resource and/or labels.",
                            "title": "PermissionInputV1",
                            "type": "object",
                            "properties": {
                                "roleId": {
                                    "description": "The role id of this permission.",
                                    "type": "string",
                                    "title": "roleId"
                                },
                                "resources": {
                                    "description": "The resources to link the selected role to.",
                                    "type": "array",
                                    "items": {
                                        "description": "The most basic representation of a resource belonging to a set of permissions.",
                                        "title": "PermissionResourceV1",
                                        "type": "object",
                                        "properties": {
                                            "id": {
                                                "description": "The id of this resource.",
                                                "type": "string",
                                                "title": "id"
                                            },
                                            "type": {
                                                "description": "The type for this resource.",
                                                "enum": [
                                                    "FUNCTION",
                                                    "SOURCE",
                                                    "SPACE",
                                                    "WAREHOUSE",
                                                    "WORKSPACE"
                                                ],
                                                "type": "string",
                                                "title": "type"
                                            },
                                            "labels": {
                                                "description": "The labels that further refine access to this resource. Labels are exclusive to Workspace-level permissions.",
                                                "type": "array",
                                                "items": {
                                                    "description": "Defines a label that you may apply to resources within a Workspace.",
                                                    "title": "AllowedLabelBeta",
                                                    "type": "object",
                                                    "properties": {
                                                        "key": {
                                                            "description": "The key identifier for this label.",
                                                            "type": "string",
                                                            "title": "key"
                                                        },
                                                        "value": {
                                                            "description": "The value of this label.",
                                                            "type": "string",
                                                            "title": "value"
                                                        },
                                                        "description": {
                                                            "description": "A description of what this label represents.",
                                                            "type": "string",
                                                            "title": "description"
                                                        }
                                                    },
                                                    "additionalProperties": false,
                                                    "required": [
                                                        "key",
                                                        "value"
                                                    ]
                                                },
                                                "title": "labels"
                                            }
                                        },
                                        "additionalProperties": false,
                                        "required": [
                                            "id",
                                            "type"
                                        ]
                                    },
                                    "title": "resources"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "resources",
                                "roleId"
                            ]
                        },
                        "title": "permissions"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "permissions"
                ]
            }
        },
        "required": [
            "userId",
            "requestBody"
        ]
    }
  },
  // Tool: addPermissionsToUser (POST /users/{userId}/permissions)
  {
    name: "addPermissionsToUser",
    description: `Adds a list of access permissions to a user.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Policy Created
* User Policy Updated
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Adds a list of permissions to a user.",
                "title": "AddPermissionsToUserV1Input",
                "type": "object",
                "properties": {
                    "permissions": {
                        "description": "The permissions to add.",
                        "type": "array",
                        "items": {
                            "description": "The input for a permission, associated with a resource and/or labels.",
                            "title": "PermissionInputV1",
                            "type": "object",
                            "properties": {
                                "roleId": {
                                    "description": "The role id of this permission.",
                                    "type": "string",
                                    "title": "roleId"
                                },
                                "resources": {
                                    "description": "The resources to link the selected role to.",
                                    "type": "array",
                                    "items": {
                                        "description": "The most basic representation of a resource belonging to a set of permissions.",
                                        "title": "PermissionResourceV1",
                                        "type": "object",
                                        "properties": {
                                            "id": {
                                                "description": "The id of this resource.",
                                                "type": "string",
                                                "title": "id"
                                            },
                                            "type": {
                                                "description": "The type for this resource.",
                                                "enum": [
                                                    "FUNCTION",
                                                    "SOURCE",
                                                    "SPACE",
                                                    "WAREHOUSE",
                                                    "WORKSPACE"
                                                ],
                                                "type": "string",
                                                "title": "type"
                                            },
                                            "labels": {
                                                "description": "The labels that further refine access to this resource. Labels are exclusive to Workspace-level permissions.",
                                                "type": "array",
                                                "items": {
                                                    "description": "Defines a label that you may apply to resources within a Workspace.",
                                                    "title": "AllowedLabelBeta",
                                                    "type": "object",
                                                    "properties": {
                                                        "key": {
                                                            "description": "The key identifier for this label.",
                                                            "type": "string",
                                                            "title": "key"
                                                        },
                                                        "value": {
                                                            "description": "The value of this label.",
                                                            "type": "string",
                                                            "title": "value"
                                                        },
                                                        "description": {
                                                            "description": "A description of what this label represents.",
                                                            "type": "string",
                                                            "title": "description"
                                                        }
                                                    },
                                                    "additionalProperties": false,
                                                    "required": [
                                                        "key",
                                                        "value"
                                                    ]
                                                },
                                                "title": "labels"
                                            }
                                        },
                                        "additionalProperties": false,
                                        "required": [
                                            "id",
                                            "type"
                                        ]
                                    },
                                    "title": "resources"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "resources",
                                "roleId"
                            ]
                        },
                        "title": "permissions"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "permissions"
                ]
            }
        },
        "required": [
            "userId",
            "requestBody"
        ]
    }
  },
  // Tool: replacePermissionsForUserGroup (PUT /groups/{userGroupId}/permissions)
  {
    name: "replacePermissionsForUserGroup",
    description: `Updates the list of access permissions for a user group.



• When called, this endpoint may generate the \`Policy Deleted\` event in the [audit trail](/tag/Audit-Trail).
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates the list of permissions for a user group.",
                "title": "ReplacePermissionsForUserGroupV1Input",
                "type": "object",
                "properties": {
                    "permissions": {
                        "description": "The permissions to replace with.",
                        "type": "array",
                        "items": {
                            "description": "The input for a permission, associated with a resource and/or labels.",
                            "title": "PermissionInputV1",
                            "type": "object",
                            "properties": {
                                "roleId": {
                                    "description": "The role id of this permission.",
                                    "type": "string",
                                    "title": "roleId"
                                },
                                "resources": {
                                    "description": "The resources to link the selected role to.",
                                    "type": "array",
                                    "items": {
                                        "description": "The most basic representation of a resource belonging to a set of permissions.",
                                        "title": "PermissionResourceV1",
                                        "type": "object",
                                        "properties": {
                                            "id": {
                                                "description": "The id of this resource.",
                                                "type": "string",
                                                "title": "id"
                                            },
                                            "type": {
                                                "description": "The type for this resource.",
                                                "enum": [
                                                    "FUNCTION",
                                                    "SOURCE",
                                                    "SPACE",
                                                    "WAREHOUSE",
                                                    "WORKSPACE"
                                                ],
                                                "type": "string",
                                                "title": "type"
                                            },
                                            "labels": {
                                                "description": "The labels that further refine access to this resource. Labels are exclusive to Workspace-level permissions.",
                                                "type": "array",
                                                "items": {
                                                    "description": "Defines a label that you may apply to resources within a Workspace.",
                                                    "title": "AllowedLabelBeta",
                                                    "type": "object",
                                                    "properties": {
                                                        "key": {
                                                            "description": "The key identifier for this label.",
                                                            "type": "string",
                                                            "title": "key"
                                                        },
                                                        "value": {
                                                            "description": "The value of this label.",
                                                            "type": "string",
                                                            "title": "value"
                                                        },
                                                        "description": {
                                                            "description": "A description of what this label represents.",
                                                            "type": "string",
                                                            "title": "description"
                                                        }
                                                    },
                                                    "additionalProperties": false,
                                                    "required": [
                                                        "key",
                                                        "value"
                                                    ]
                                                },
                                                "title": "labels"
                                            }
                                        },
                                        "additionalProperties": false,
                                        "required": [
                                            "id",
                                            "type"
                                        ]
                                    },
                                    "title": "resources"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "resources",
                                "roleId"
                            ]
                        },
                        "title": "permissions"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "permissions"
                ]
            }
        },
        "required": [
            "userGroupId",
            "requestBody"
        ]
    }
  },
  // Tool: addPermissionsToUserGroup (POST /groups/{userGroupId}/permissions)
  {
    name: "addPermissionsToUserGroup",
    description: `Adds a list of access permissions to a user group.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Policy Created
* User Group Policy Updated
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Adds a list of permissions to a user group.",
                "title": "AddPermissionsToUserGroupV1Input",
                "type": "object",
                "properties": {
                    "permissions": {
                        "description": "The permissions to add.",
                        "type": "array",
                        "items": {
                            "description": "The input for a permission, associated with a resource and/or labels.",
                            "title": "PermissionInputV1",
                            "type": "object",
                            "properties": {
                                "roleId": {
                                    "description": "The role id of this permission.",
                                    "type": "string",
                                    "title": "roleId"
                                },
                                "resources": {
                                    "description": "The resources to link the selected role to.",
                                    "type": "array",
                                    "items": {
                                        "description": "The most basic representation of a resource belonging to a set of permissions.",
                                        "title": "PermissionResourceV1",
                                        "type": "object",
                                        "properties": {
                                            "id": {
                                                "description": "The id of this resource.",
                                                "type": "string",
                                                "title": "id"
                                            },
                                            "type": {
                                                "description": "The type for this resource.",
                                                "enum": [
                                                    "FUNCTION",
                                                    "SOURCE",
                                                    "SPACE",
                                                    "WAREHOUSE",
                                                    "WORKSPACE"
                                                ],
                                                "type": "string",
                                                "title": "type"
                                            },
                                            "labels": {
                                                "description": "The labels that further refine access to this resource. Labels are exclusive to Workspace-level permissions.",
                                                "type": "array",
                                                "items": {
                                                    "description": "Defines a label that you may apply to resources within a Workspace.",
                                                    "title": "AllowedLabelBeta",
                                                    "type": "object",
                                                    "properties": {
                                                        "key": {
                                                            "description": "The key identifier for this label.",
                                                            "type": "string",
                                                            "title": "key"
                                                        },
                                                        "value": {
                                                            "description": "The value of this label.",
                                                            "type": "string",
                                                            "title": "value"
                                                        },
                                                        "description": {
                                                            "description": "A description of what this label represents.",
                                                            "type": "string",
                                                            "title": "description"
                                                        }
                                                    },
                                                    "additionalProperties": false,
                                                    "required": [
                                                        "key",
                                                        "value"
                                                    ]
                                                },
                                                "title": "labels"
                                            }
                                        },
                                        "additionalProperties": false,
                                        "required": [
                                            "id",
                                            "type"
                                        ]
                                    },
                                    "title": "resources"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "resources",
                                "roleId"
                            ]
                        },
                        "title": "permissions"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "permissions"
                ]
            }
        },
        "required": [
            "userGroupId",
            "requestBody"
        ]
    }
  },
  // Tool: listSourcesFromTrackingPlan (GET /tracking-plans/{trackingPlanId}/sources)
  {
    name: "listSourcesFromTrackingPlan",
    description: `Lists Sources connected to a Tracking Plan.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.


This endpoint requires the user to have at least the following permission(s): 
 * Source Read-only
 * Tracking Plan Read-only`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Pagination options.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "trackingPlanId"
        ]
    }
  },
  // Tool: addSourceToTrackingPlan (POST /tracking-plans/{trackingPlanId}/sources)
  {
    name: "addSourceToTrackingPlan",
    description: `Connects a Source to a Tracking Plan.



• When called, this endpoint may generate the \`Source Modified\` event in the [audit trail](/tag/Audit-Trail).


• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Connects a Source to a Tracking Plan.",
                "title": "AddSourceToTrackingPlanV1Input",
                "type": "object",
                "properties": {
                    "sourceId": {
                        "description": "The id of the Source associated with the Tracking Plan.\n\nConfig API note: analogous to `sourceName`.",
                        "type": "string",
                        "title": "sourceId"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "sourceId"
                ]
            }
        },
        "required": [
            "trackingPlanId",
            "requestBody"
        ]
    }
  },
  // Tool: removeSourceFromTrackingPlan (DELETE /tracking-plans/{trackingPlanId}/sources)
  {
    name: "removeSourceFromTrackingPlan",
    description: `Disconnects a Source from a Tracking Plan.



• When called, this endpoint may generate the \`Source Modified\` event in the [audit trail](/tag/Audit-Trail).


• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "sourceId": {
                "description": "The id of the Source associated with the Tracking Plan.\n\nConfig API note: analogous to `sourceName`.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "sourceId"
            }
        },
        "required": [
            "trackingPlanId",
            "sourceId"
        ]
    }
  },
  // Tool: listUsersFromUserGroup (GET /groups/{userGroupId}/users)
  {
    name: "listUsersFromUserGroup",
    description: `Returns users belonging to a user group.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Pagination for members of a group.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "userGroupId"
        ]
    }
  },
  // Tool: addUsersToUserGroup (POST /groups/{userGroupId}/users)
  {
    name: "addUsersToUserGroup",
    description: `Adds a list of users or invites to a user group.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Subjects Added to Group
* User Added To User Group
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Adds a list of users and invites to a user group.",
                "title": "AddUsersToUserGroupV1Input",
                "type": "object",
                "properties": {
                    "emails": {
                        "description": "The email addresses of the users and invites to add.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "emails"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "emails"
                ]
            }
        },
        "required": [
            "userGroupId",
            "requestBody"
        ]
    }
  },
  // Tool: batchQueryMessagingSubscriptionsForSpace (POST /spaces/{spaceId}/messaging-subscriptions/batch)
  {
    name: "batchQueryMessagingSubscriptionsForSpace",
    description: `
<div style="background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 16px; margin: 16px 0; color: #856404; display: flex; align-items: center; gap: 12px; line-height: 1.5;">
  <span style="color: #ff9800; font-size: 16px; flex-shrink: 0;">⚠️</span>
  <div style="line-height: 1.5;">
    <div style="font-weight: 600; font-size: 14px; margin-bottom: 6px;">
      Engage Premier features will no longer be available after December 15, 2025.
    </div>
    <div style="font-size: 13px;">
      This API will be deactivated after this date.
    </div>
  </div>
</div>
Get Messaging Subscriptions for space.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Spaces feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "requestBody"
        ]
    }
  },
  // Tool: cancelReverseETLSyncForModel (POST /reverse-etl-models/{modelId}/syncs/{syncId}/cancel)
  {
    name: "cancelReverseETLSyncForModel",
    description: `Cancels a sync for a Reverse ETL Connection. It might take a few seconds to completely cancel the sync. 

Will return an error if the sync is already completed or cancelled.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "modelId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "syncId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "modelId",
            "syncId",
            "requestBody"
        ]
    }
  },
  // Tool: listAudiences (GET /spaces/{spaceId}/audiences)
  {
    name: "listAudiences",
    description: `Returns Audiences by spaceId. Supports including audience schedules via \`?include=schedules\`.

• This endpoint is in **Beta** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 25 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "search": {
                "description": "Optional search criteria\n\nThis parameter exists in alpha.",
                "title": "ListAudienceSearchInput",
                "type": "object",
                "properties": {
                    "type": {
                        "description": "Field to filter by.",
                        "enum": [
                            "DEFINITION",
                            "KEY",
                            "NAME"
                        ],
                        "type": "string",
                        "title": "type"
                    },
                    "query": {
                        "description": "Text to match against the selected field (max 255 characters).\nWhen searching by KEY, a prefix match is used. For all other options, a full wildcard search will be used.",
                        "type": "string",
                        "title": "query"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "query",
                    "type"
                ]
            },
            "pagination": {
                "description": "Information about the pagination of this response.\n\n[See pagination](https://docs.segmentapis.com/tag/Pagination/#section/Pagination-parameters) for more info.\n\nThis parameter exists in alpha.",
                "title": "ListAudiencesPaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 200.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            },
            "include": {
                "description": "Additional resource to include, support schedules only.\n\nThis parameter exists in alpha.",
                "enum": [
                    "schedules"
                ],
                "type": "string",
                "title": "include"
            }
        },
        "required": [
            "spaceId"
        ]
    }
  },
  // Tool: createAudience (POST /spaces/{spaceId}/audiences)
  {
    name: "createAudience",
    description: `Creates Audience.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Audience Created\` event in the [audit trail](/tag/Audit-Trail).
 Note: The definition for an Audience created using the API is not editable through the Segment App.


The rate limit for this endpoint is 10 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "requestBody"
        ]
    }
  },
  // Tool: createAudiencePreview (POST /spaces/{spaceId}/audiences/previews)
  {
    name: "createAudiencePreview",
    description: `Previews Audience.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Audience Preview Created\` event in the [audit trail](/tag/Audit-Trail).


The rate limit for this endpoint is 5 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.
This endpoint also has a rate limit of 700 requests per month per spaceId, which is lower than the default due to access pattern restrictions.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "requestBody"
        ]
    }
  },
  // Tool: createCloudSourceRegulation (POST /regulations/cloudsources/{sourceId})
  {
    name: "createCloudSourceRegulation",
    description: `Creates a Source-scoped regulation. 

 Please Note: Suppression rules at the Workspace level take precedence over those at the Source level. If a user has been suppressed at the Workspace level, any attempt to un-suppress at the Source level is not supported and the processing of the request will fail in Segment

      Config API omitted fields:
- \`attributes\`,
- \`userAgent\`
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "The input to create a Cloud Source-scoped regulation.",
                "title": "CreateCloudSourceRegulationV1Input",
                "type": "object",
                "properties": {
                    "regulationType": {
                        "description": "The regulation type to create.",
                        "enum": [
                            "DELETE_INTERNAL",
                            "DELETE_ONLY",
                            "SUPPRESS_ONLY",
                            "SUPPRESS_WITH_DELETE",
                            "SUPPRESS_WITH_DELETE_INTERNAL",
                            "UNSUPPRESS"
                        ],
                        "type": "string",
                        "title": "regulationType"
                    },
                    "subjectType": {
                        "description": "The subject type. Must be `objectId` for Cloud Sources.",
                        "type": "string",
                        "enum": [
                            "OBJECT_ID"
                        ],
                        "title": "subjectType"
                    },
                    "subjectIds": {
                        "description": "The list of `userId` or `objectId` values of the subjects to regulate.\n\nConfig API note: equal to `parent` but allows an array.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "subjectIds"
                    },
                    "collection": {
                        "description": "The Cloud Source collection to regulate.",
                        "type": "string",
                        "title": "collection"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "collection",
                    "regulationType",
                    "subjectIds",
                    "subjectType"
                ]
            }
        },
        "required": [
            "sourceId",
            "requestBody"
        ]
    }
  },
  // Tool: listComputedTraits (GET /spaces/{spaceId}/computed-traits)
  {
    name: "listComputedTraits",
    description: `Returns Computed Traits by spaceId.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Computed Trait feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 25 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Information about the pagination of this response.\n\n[See pagination](https://docs.segmentapis.com/tag/Pagination/#section/Pagination-parameters) for more info.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "spaceId"
        ]
    }
  },
  // Tool: createComputedTrait (POST /spaces/{spaceId}/computed-traits)
  {
    name: "createComputedTrait",
    description: `Creates a Computed Trait

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Computed Trait feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Computed Trait Created\` event in the [audit trail](/tag/Audit-Trail).
 Note: The definition for a Computed Trait created using the API is not editable through the Segment App.


The rate limit for this endpoint is 10 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "requestBody"
        ]
    }
  },
  // Tool: createDbtModelSyncTrigger (POST /dbt-model-syncs/trigger)
  {
    name: "createDbtModelSyncTrigger",
    description: `Creates a trigger for a new dbt model sync for a Source.


The rate limit for this endpoint is 10 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1beta+json)"
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listDestinations (GET /destinations)
  {
    name: "listDestinations",
    description: `Returns a list of Destinations.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Required pagination params for the request.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createDestination (POST /destinations)
  {
    name: "createDestination",
    description: `Creates a new Destination.



• When called, this endpoint may generate the \`Integration Created\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Creates a new Destination.",
                "title": "CreateDestinationV1Input",
                "type": "object",
                "properties": {
                    "sourceId": {
                        "description": "The id of the Source to connect to this Destination instance.\n\nConfig API note: analogous to `parent`.",
                        "type": "string",
                        "title": "sourceId"
                    },
                    "metadataId": {
                        "description": "The id of the metadata to link to the new Destination.",
                        "type": "string",
                        "title": "metadataId"
                    },
                    "enabled": {
                        "description": "Whether this Destination should receive data.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "name": {
                        "description": "Defines the display name of the Destination.\n\nConfig API note: equal to `displayName`.",
                        "type": "string",
                        "title": "name"
                    },
                    "settings": {
                        "description": "An object that contains settings for the Destination based on the \"required\" and \"advanced\" settings present in the\nDestination metadata.\n\nConfig API note: equal to `config`.",
                        "type": "object",
                        "additionalProperties": true,
                        "title": "settings"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "metadataId",
                    "settings",
                    "sourceId"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listSubscriptionsFromDestination (GET /destinations/{destinationId}/subscriptions)
  {
    name: "listSubscriptionsFromDestination",
    description: `Lists subscriptions for a Destination.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Destination Subscriptions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Pagination options.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "destinationId"
        ]
    }
  },
  // Tool: createDestinationSubscription (POST /destinations/{destinationId}/subscriptions)
  {
    name: "createDestinationSubscription",
    description: `Creates a new Destination subscription.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Destination Subscriptions feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 5 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "destinationId",
            "requestBody"
        ]
    }
  },
  // Tool: createDownload (POST /customer-insights/download)
  {
    name: "createDownload",
    description: `Create Customer Insights Presigned URLsThe rate limit for this endpoint is 120 requests per day per workspaceId, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: createEdgeFunctions (POST /sources/{sourceId}/edge-functions)
  {
    name: "createEdgeFunctions",
    description: `Create EdgeFunctions for your Source given a valid upload URL for an Edge Functions bundle.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Edge Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "sourceId",
            "requestBody"
        ]
    }
  },
  // Tool: listFiltersFromDestination (GET /destination/{destinationId}/filters)
  {
    name: "listFiltersFromDestination",
    description: `Lists filters for a Destination.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Pagination options.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "destinationId"
        ]
    }
  },
  // Tool: createFilterForDestination (POST /destination/{destinationId}/filters)
  {
    name: "createFilterForDestination",
    description: `Creates a filter in a Destination.



• When called, this endpoint may generate the \`Destination Filter Created\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Input for CreateDestinationFilterV1.",
                "title": "CreateFilterForDestinationV1Input",
                "type": "object",
                "properties": {
                    "sourceId": {
                        "description": "The id of the Source associated with this filter.",
                        "type": "string",
                        "title": "sourceId"
                    },
                    "if": {
                        "description": "The filter's condition.",
                        "type": "string",
                        "title": "if"
                    },
                    "actions": {
                        "description": "Actions for the Destination filter.",
                        "type": "array",
                        "items": {
                            "description": "Represents a Destination filter action.",
                            "title": "DestinationFilterActionV1",
                            "type": "object",
                            "properties": {
                                "type": {
                                    "description": "The kind of Transformation to apply to any matched properties.",
                                    "enum": [
                                        "ALLOW_PROPERTIES",
                                        "DROP",
                                        "DROP_PROPERTIES",
                                        "SAMPLE"
                                    ],
                                    "type": "string",
                                    "title": "type"
                                },
                                "fields": {
                                    "description": "A dictionary of paths to object keys that this filter applies to.\n The literal string '' represents the top level of the object.",
                                    "type": "object",
                                    "additionalProperties": true,
                                    "title": "fields"
                                },
                                "percent": {
                                    "description": "A decimal between 0 and 1 used for 'sample' type events and\ninfluences the likelihood of sampling to occur.",
                                    "type": "number",
                                    "title": "percent"
                                },
                                "path": {
                                    "description": "The JSON path to a property within a payload object from which Segment generates a deterministic\nsampling rate.",
                                    "type": "string",
                                    "title": "path"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "type"
                            ]
                        },
                        "title": "actions"
                    },
                    "title": {
                        "description": "The title of the filter.",
                        "type": "string",
                        "title": "title"
                    },
                    "description": {
                        "description": "The description of the filter.",
                        "type": "string",
                        "title": "description"
                    },
                    "enabled": {
                        "description": "When set to true, the Destination filter is active.",
                        "type": "boolean",
                        "title": "enabled"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "actions",
                    "enabled",
                    "if",
                    "sourceId",
                    "title"
                ]
            }
        },
        "required": [
            "destinationId",
            "requestBody"
        ]
    }
  },
  // Tool: listFiltersForSpace (GET /filters)
  {
    name: "listFiltersForSpace",
    description: `Lists filters for a space.

• This endpoint is in **Beta** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Space Filters feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "integrationId": {
                "description": "The Space Id for which to fetch filters\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "integrationId"
            },
            "pagination": {
                "description": "Pagination parameters.\n\nThis parameter exists in beta.",
                "title": "ListFiltersPaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The offset.",
                        "type": "number",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 10.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "integrationId"
        ]
    }
  },
  // Tool: createFilterForSpace (POST /filters)
  {
    name: "createFilterForSpace",
    description: `Creates a filter for a space. A space filter applies to events coming from all Sources connected to a space.



• This endpoint is in **Beta** testing.  Please submit any feedback by sending an email to friends@segment.com.



• In order to successfully call this endpoint, the specified Workspace needs to have the Space Filters feature enabled. Please reach out to your customer success manager for more information.


• When called, this endpoint may generate the \`Filter Created\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1beta+json)"
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listFunctions (GET /functions)
  {
    name: "listFunctions",
    description: `Lists all Functions in a Workspace.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            },
            "resourceType": {
                "description": "The Function type.\n\nConfig API note: equal to `type`.\n\nThis parameter exists in v1.",
                "enum": [
                    "DESTINATION",
                    "INSERT_DESTINATION",
                    "INSERT_SOURCE",
                    "SOURCE"
                ],
                "type": "string",
                "title": "resourceType"
            }
        },
        "required": [
            "resourceType"
        ]
    }
  },
  // Tool: createFunction (POST /functions)
  {
    name: "createFunction",
    description: `Creates a Function.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Creates a Function.",
                "title": "CreateFunctionV1Input",
                "type": "object",
                "properties": {
                    "code": {
                        "description": "The Function code.",
                        "type": "string",
                        "title": "code"
                    },
                    "settings": {
                        "description": "The list of settings for this Function.",
                        "type": "array",
                        "items": {
                            "title": "FunctionSettingV1",
                            "type": "object",
                            "properties": {
                                "name": {
                                    "description": "The name of this Function Setting.",
                                    "type": "string",
                                    "title": "name"
                                },
                                "label": {
                                    "description": "The label for this Function Setting.",
                                    "type": "string",
                                    "title": "label"
                                },
                                "description": {
                                    "description": "A description of this Function Setting.",
                                    "type": "string",
                                    "title": "description"
                                },
                                "type": {
                                    "description": "The type of this Function Setting.",
                                    "enum": [
                                        "ARRAY",
                                        "BOOLEAN",
                                        "STRING",
                                        "TEXT_MAP"
                                    ],
                                    "type": "string",
                                    "title": "type"
                                },
                                "required": {
                                    "description": "Whether this Function Setting is required.",
                                    "type": "boolean",
                                    "title": "required"
                                },
                                "sensitive": {
                                    "description": "Whether this Function Setting contains sensitive information.",
                                    "type": "boolean",
                                    "title": "sensitive"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "description",
                                "label",
                                "name",
                                "required",
                                "sensitive",
                                "type"
                            ]
                        },
                        "title": "settings"
                    },
                    "displayName": {
                        "description": "A display name for this Function.\n\nNote that Destination Functions append the Workspace to the display name.",
                        "type": "string",
                        "title": "displayName"
                    },
                    "logoUrl": {
                        "description": "The URL of the logo for this Function.",
                        "type": "string",
                        "title": "logoUrl"
                    },
                    "resourceType": {
                        "description": "The Function type.\n\nConfig API note: equal to `type`.",
                        "enum": [
                            "DESTINATION",
                            "INSERT_DESTINATION",
                            "INSERT_SOURCE",
                            "SOURCE"
                        ],
                        "type": "string",
                        "title": "resourceType"
                    },
                    "description": {
                        "description": "A description for this Function.",
                        "type": "string",
                        "title": "description"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "code",
                    "displayName",
                    "resourceType"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: createFunctionDeployment (POST /functions/{functionId}/deploy)
  {
    name: "createFunctionDeployment",
    description: `Deploys a Function. Only applicable to Source Function instances.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "functionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "functionId"
        ]
    }
  },
  // Tool: listInsertFunctionInstances (GET /insert-function-instances)
  {
    name: "listInsertFunctionInstances",
    description: `Lists all insert Function instances connected to the given insert Function.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Pagination parameters.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            },
            "functionId": {
                "description": "The insert Function class id to lookup.\n\nThis parameter exists in alpha.",
                "type": "string",
                "title": "functionId"
            }
        },
        "required": [
            "functionId"
        ]
    }
  },
  // Tool: createInsertFunctionInstance (POST /insert-function-instances)
  {
    name: "createInsertFunctionInstance",
    description: `Creates an insert Function instance connected to the given Destination.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listInvites (GET /invites)
  {
    name: "listInvites",
    description: `Returns a list of invitations to join a Workspace.

Config API omitted fields:
- \`parent\`
`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createInvites (POST /invites)
  {
    name: "createInvites",
    description: `Invites a list of users to join a Workspace.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Non-Segment User Invited to Workspace
* Policy Created
* New Segment User Invited to Workspace

Config API omitted fields:
- \`parent\`
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Invites a user to a Workspace with specified permissions.",
                "title": "CreateInvitesV1Input",
                "type": "object",
                "properties": {
                    "invites": {
                        "description": "The list of invites.",
                        "type": "array",
                        "items": {
                            "description": "Defines an invitation to join a Workspace.",
                            "title": "InviteV1",
                            "type": "object",
                            "properties": {
                                "email": {
                                    "description": "The invited user's email to attach the permissions to.",
                                    "type": "string",
                                    "title": "email"
                                },
                                "permissions": {
                                    "description": "The permissions to attach to the invited user.",
                                    "type": "array",
                                    "items": {
                                        "description": "Defines a permission to apply to the user in an invite.",
                                        "title": "InvitePermissionV1",
                                        "type": "object",
                                        "properties": {
                                            "roleId": {
                                                "description": "The id of the role.",
                                                "type": "string",
                                                "title": "roleId"
                                            },
                                            "resources": {
                                                "description": "The resources to grant the invited users access to.",
                                                "type": "array",
                                                "items": {
                                                    "description": "Represents a permission's resource.",
                                                    "title": "ResourceV1",
                                                    "type": "object",
                                                    "properties": {
                                                        "id": {
                                                            "description": "The id of this resource.",
                                                            "type": "string",
                                                            "title": "id"
                                                        },
                                                        "type": {
                                                            "description": "The kind of resource this permission applies to.",
                                                            "enum": [
                                                                "FUNCTION",
                                                                "SOURCE",
                                                                "SPACE",
                                                                "WAREHOUSE",
                                                                "WORKSPACE"
                                                            ],
                                                            "type": "string",
                                                            "title": "type"
                                                        }
                                                    },
                                                    "additionalProperties": false,
                                                    "required": [
                                                        "id",
                                                        "type"
                                                    ]
                                                },
                                                "title": "resources"
                                            },
                                            "labels": {
                                                "description": "The labels that determine which resources to grant users access to.",
                                                "type": "array",
                                                "items": {
                                                    "description": "Defines a label that you may apply to resources within a Workspace.",
                                                    "title": "AllowedLabelBeta",
                                                    "type": "object",
                                                    "properties": {
                                                        "key": {
                                                            "description": "The key identifier for this label.",
                                                            "type": "string",
                                                            "title": "key"
                                                        },
                                                        "value": {
                                                            "description": "The value of this label.",
                                                            "type": "string",
                                                            "title": "value"
                                                        },
                                                        "description": {
                                                            "description": "A description of what this label represents.",
                                                            "type": "string",
                                                            "title": "description"
                                                        }
                                                    },
                                                    "additionalProperties": false,
                                                    "required": [
                                                        "key",
                                                        "value"
                                                    ]
                                                },
                                                "title": "labels"
                                            }
                                        },
                                        "additionalProperties": false,
                                        "required": [
                                            "roleId"
                                        ]
                                    },
                                    "title": "permissions"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "email"
                            ]
                        },
                        "title": "invites"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "invites"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: deleteInvites (DELETE /invites)
  {
    name: "deleteInvites",
    description: `Removes a list of invitations to join a Workspace.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Invite Deleted
* Group Memberships Deleted
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "emails": {
                "description": "The list of emails to delete invites for.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "emails"
            }
        },
        "required": [
            "emails"
        ]
    }
  },
  // Tool: listLabels (GET /labels)
  {
    name: "listLabels",
    description: `Returns a list of all available labels.`,
    inputSchema:     {
        "type": "object",
        "properties": {}
    }
  },
  // Tool: createLabel (POST /labels)
  {
    name: "createLabel",
    description: `Creates a new label.



• When called, this endpoint may generate the \`Label Created\` event in the [audit trail](/tag/Audit-Trail).
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Creates a new label in the current Workspace.",
                "title": "CreateLabelV1Input",
                "type": "object",
                "properties": {
                    "label": {
                        "description": "The new label to create in the Workspace.",
                        "title": "label",
                        "allOf": [
                            {
                                "description": "A label lets Workspace owners assign permissions to users, and grant these users access to groups.\n\nA Workspace owner may use labels to grant users access to groups of resources.\n\nWhen you add a label to a Source or Personas Spaces, any users granted access to that label gain access to those\nresources.\n\nAll Workspaces include labels for Dev (development) and Prod (production) environments. On top of those, Free and\nTeam plan customers may create up to five labels.\n\nCustomers with the Enterprise pricing package may create an unlimited number of labels.",
                                "title": "LabelV1",
                                "type": "object",
                                "properties": {
                                    "key": {
                                        "description": "The key that represents the name of this label.",
                                        "type": "string",
                                        "title": "key"
                                    },
                                    "value": {
                                        "description": "The value associated with the key of this label.",
                                        "type": "string",
                                        "title": "value"
                                    },
                                    "description": {
                                        "description": "An optional description of the purpose of this label.",
                                        "type": "string",
                                        "title": "description"
                                    }
                                },
                                "additionalProperties": false,
                                "required": [
                                    "key",
                                    "value"
                                ]
                            }
                        ]
                    }
                },
                "additionalProperties": false,
                "required": [
                    "label"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listProfilesWarehouseInSpace (GET /spaces/{spaceId}/profiles-warehouses)
  {
    name: "listProfilesWarehouseInSpace",
    description: `Lists all Profile Warehouses for a given space id.



• When called, this endpoint may generate the \`Profiles Sync Warehouse Retrieved\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "spaceId"
        ]
    }
  },
  // Tool: createProfilesWarehouse (POST /spaces/{spaceId}/profiles-warehouses)
  {
    name: "createProfilesWarehouse",
    description: `Creates a new Profiles Warehouse.



• When called, this endpoint may generate the \`Profiles Sync Warehouse Created\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "requestBody"
        ]
    }
  },
  // Tool: createReverseETLManualSync (POST /reverse-etl-syncs)
  {
    name: "createReverseETLManualSync",
    description: `Triggers a manual sync for a Reverse ETL Connection. 

In the request body, the \`subscription id\` is the id that follows after \`/mappings/\` portion in the URL of the sync. 

For example, the \`subscription id\` would be \`2\` for this sync: https://app.Segment.com/example-workspace/reverse-etl/destinations/example-destination/sources/example-source/instances/1/mappings/2/source-id/3/model-id/4/sync-details


The rate limit for this endpoint is 20 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listReverseEtlModels (GET /reverse-etl-models)
  {
    name: "listReverseEtlModels",
    description: `Returns a list of Reverse ETL Models.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createReverseEtlModel (POST /reverse-etl-models)
  {
    name: "createReverseEtlModel",
    description: `Creates a new Reverse ETL Model.

      

• When called, this endpoint may generate the \`Model Created\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listSources (GET /sources)
  {
    name: "listSources",
    description: `Returns a list of Sources.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createSource (POST /sources)
  {
    name: "createSource",
    description: `Creates a new Source.



• When called, this endpoint may generate the \`Source Created\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Create a new Source based on a set of parameters.",
                "title": "CreateSourceV1Input",
                "type": "object",
                "properties": {
                    "slug": {
                        "description": "The slug by which to identify the Source in the Segment app.",
                        "type": "string",
                        "title": "slug"
                    },
                    "enabled": {
                        "description": "Enable to allow this Source to send data. Defaults to true.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "metadataId": {
                        "description": "The id of the Source metadata from which this instance of the Source derives.\n\nAll Source metadata is available under `/catalog/sources`.",
                        "type": "string",
                        "title": "metadataId"
                    },
                    "settings": {
                        "description": "A key-value object that contains instance-specific settings for the Source.\n\n\"websiteUrl\" and \"apiHost\" can be configured here for the relevant Sources.",
                        "title": "settings",
                        "allOf": [
                            {
                                "description": "A key-value object that contains instance-specific settings for a Source.\n\nThe `options` field in the Source metadata defines the schema of this object.",
                                "title": "SourceSettingsV1",
                                "type": "object",
                                "additionalProperties": {}
                            }
                        ]
                    },
                    "disconnectAllWarehouses": {
                        "description": "Whether to disconnect all Warehouses from the Source.",
                        "type": "boolean",
                        "title": "disconnectAllWarehouses"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "enabled",
                    "metadataId",
                    "slug"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listRegulationsFromSource (GET /regulations/sources/{sourceId})
  {
    name: "listRegulationsFromSource",
    description: `Lists all Source-scoped regulations.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "status": {
                "description": "The status on which to filter returned regulations.\n\nThis parameter exists in v1.",
                "enum": [
                    "FAILED",
                    "FINISHED",
                    "INITIALIZED",
                    "INVALID",
                    "NOT_SUPPORTED",
                    "PARTIAL_SUCCESS",
                    "RUNNING"
                ],
                "type": "string",
                "title": "status"
            },
            "regulationTypes": {
                "description": "The regulation types on which to filter returned regulations.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "enum": [
                        "DELETE_ARCHIVE_ONLY",
                        "DELETE_INTERNAL",
                        "DELETE_ONLY",
                        "SUPPRESS_ONLY",
                        "SUPPRESS_WITH_DELETE",
                        "SUPPRESS_WITH_DELETE_INTERNAL",
                        "UNSUPPRESS"
                    ],
                    "type": "string"
                },
                "title": "regulationTypes"
            },
            "pagination": {
                "description": "Pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: createSourceRegulation (POST /regulations/sources/{sourceId})
  {
    name: "createSourceRegulation",
    description: `Creates a Source-scoped regulation. 

 Please Note: Suppression rules at the Workspace level take precedence over those at the Source level. If a user has been suppressed at the Workspace level, any attempt to un-suppress at the Source level is not supported and the processing of the request will fail in Segment



• When called, this endpoint may generate the \`Source Regulation Created\` event in the [audit trail](/tag/Audit-Trail).

Config API omitted fields:
- \`attributes\`,
- \`userAgent\`
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "The input to create a Source-scoped regulation.",
                "title": "CreateSourceRegulationV1Input",
                "type": "object",
                "properties": {
                    "regulationType": {
                        "description": "The regulation type to create.\nPlease note that `DELETE_ARCHIVE_ONLY` is only supported for limited Workspaces for Source-scoped regulations.",
                        "enum": [
                            "DELETE_ARCHIVE_ONLY",
                            "DELETE_INTERNAL",
                            "DELETE_ONLY",
                            "SUPPRESS_ONLY",
                            "SUPPRESS_WITH_DELETE",
                            "SUPPRESS_WITH_DELETE_INTERNAL",
                            "UNSUPPRESS"
                        ],
                        "type": "string",
                        "title": "regulationType"
                    },
                    "subjectType": {
                        "description": "The subject type.\nNote: `ANONYMOUS_ID` is only supported for limited Workspaces for Source-scoped regulations. `ANONYMOUS_ID` is only supported when regulationType is `DELETE_ARCHIVE_ONLY`.",
                        "enum": [
                            "ANONYMOUS_ID",
                            "USER_ID"
                        ],
                        "type": "string",
                        "title": "subjectType"
                    },
                    "subjectIds": {
                        "description": "The list of `userId` or `objectId` or `anonymousId` values of the subjects to regulate.\n\nConfig API note: equal to `parent` but allows an array.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "subjectIds"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "regulationType",
                    "subjectIds",
                    "subjectType"
                ]
            }
        },
        "required": [
            "sourceId",
            "requestBody"
        ]
    }
  },
  // Tool: listTrackingPlans (GET /tracking-plans)
  {
    name: "listTrackingPlans",
    description: `Returns a list of Tracking Plans.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "type": {
                "description": "Requests Tracking Plans of a certain type. If omitted, lists all types.\n\nThis parameter exists in v1.",
                "enum": [
                    "ENGAGE",
                    "LIVE",
                    "PROPERTY_LIBRARY",
                    "RULE_LIBRARY",
                    "TEMPLATE"
                ],
                "type": "string",
                "title": "type"
            },
            "pagination": {
                "description": "Pagination options.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createTrackingPlan (POST /tracking-plans)
  {
    name: "createTrackingPlan",
    description: `Creates a Tracking Plan.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Creates a Tracking Plan in the Workspace.",
                "title": "CreateTrackingPlanV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "The Tracking Plan's name.\n\nConfig API note: equal to `displayName`.",
                        "type": "string",
                        "title": "name"
                    },
                    "description": {
                        "description": "The Tracking Plan's description.",
                        "type": "string",
                        "title": "description"
                    },
                    "type": {
                        "description": "The Tracking Plan's type.",
                        "enum": [
                            "ENGAGE",
                            "LIVE",
                            "PROPERTY_LIBRARY",
                            "RULE_LIBRARY",
                            "TEMPLATE"
                        ],
                        "type": "string",
                        "title": "type"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "name",
                    "type"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listTransformations (GET /transformations)
  {
    name: "listTransformations",
    description: `Lists all Transformations in the Workspace.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Pagination options.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createTransformation (POST /transformations)
  {
    name: "createTransformation",
    description: `Creates a new Transformation.



• When called, this endpoint may generate the \`Transformation Created\` event in the [audit trail](/tag/Audit-Trail).


• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "The input to create a Transformation.",
                "title": "CreateTransformationV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "The name of the Transformation.",
                        "type": "string",
                        "title": "name"
                    },
                    "sourceId": {
                        "description": "The Source to be associated with the Transformation.",
                        "type": "string",
                        "title": "sourceId"
                    },
                    "destinationMetadataId": {
                        "description": "The optional Destination metadata id to be associated with the Transformation.",
                        "type": "string",
                        "title": "destinationMetadataId"
                    },
                    "enabled": {
                        "description": "If the Transformation should be enabled.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "if": {
                        "description": "If statement ([FQL](https://segment.com/docs/config-api/fql/)) to match events.\n\nFor standard event matchers, use the following:\n Track -\\> \"event='\\<eventName\\>'\"\n Identify -\\> \"type='identify'\"\n Group -\\> \"type='group'\"",
                        "type": "string",
                        "title": "if"
                    },
                    "drop": {
                        "description": "Optional boolean value if the Transformation should drop the event entirely when the if statement matches, ignores all other transforms.",
                        "type": "boolean",
                        "title": "drop"
                    },
                    "newEventName": {
                        "description": "Optional new event name for renaming events. Works only for 'track' event type.",
                        "type": "string",
                        "title": "newEventName"
                    },
                    "propertyRenames": {
                        "description": "Optional array for renaming properties collected by your events.",
                        "type": "array",
                        "items": {
                            "title": "PropertyRenameV1",
                            "type": "object",
                            "properties": {
                                "oldName": {
                                    "description": "The old name of the property.",
                                    "type": "string",
                                    "title": "oldName"
                                },
                                "newName": {
                                    "description": "The new name to rename the property.",
                                    "type": "string",
                                    "title": "newName"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "newName",
                                "oldName"
                            ]
                        },
                        "title": "propertyRenames"
                    },
                    "propertyValueTransformations": {
                        "description": "Optional array for transforming properties and values collected by your events. Limited to 10 properties.",
                        "type": "array",
                        "items": {
                            "title": "PropertyValueTransformationV1",
                            "type": "object",
                            "properties": {
                                "propertyPaths": {
                                    "description": "The property paths. The maximum number of paths is 10.",
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    },
                                    "title": "propertyPaths"
                                },
                                "propertyValue": {
                                    "description": "The new value of the property paths.",
                                    "type": "string",
                                    "title": "propertyValue"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "propertyPaths",
                                "propertyValue"
                            ]
                        },
                        "title": "propertyValueTransformations"
                    },
                    "fqlDefinedProperties": {
                        "description": "Optional array for defining new properties in [FQL](https://segment.com/docs/config-api/fql/). Currently limited to 1 property.",
                        "type": "array",
                        "items": {
                            "title": "FQLDefinedPropertyV1",
                            "type": "object",
                            "properties": {
                                "fql": {
                                    "description": "The FQL expression used to compute the property.",
                                    "type": "string",
                                    "title": "fql"
                                },
                                "propertyName": {
                                    "description": "The new property name.",
                                    "type": "string",
                                    "title": "propertyName"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "fql",
                                "propertyName"
                            ]
                        },
                        "title": "fqlDefinedProperties"
                    },
                    "allowProperties": {
                        "description": "Optional array for allowing properties from your events.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "allowProperties"
                    },
                    "hashPropertiesConfiguration": {
                        "description": "Optional object for hashing properties within an event.",
                        "title": "hashPropertiesConfiguration",
                        "allOf": [
                            {
                                "title": "HashPropertiesConfiguration",
                                "type": "object",
                                "properties": {
                                    "algorithm": {
                                        "description": "Which algorithm to use to hash to properties.",
                                        "type": "string",
                                        "title": "algorithm"
                                    },
                                    "key": {
                                        "description": "Optional key to hash with.",
                                        "type": "string",
                                        "title": "key"
                                    },
                                    "encoding": {
                                        "description": "Optional encoding to use for the hashing.",
                                        "enum": [
                                            "BASE16",
                                            "BASE64",
                                            "BASE64URL",
                                            "HEX"
                                        ],
                                        "type": "string",
                                        "title": "encoding"
                                    },
                                    "paths": {
                                        "description": "The paths to the properties to be hashed.",
                                        "type": "array",
                                        "items": {
                                            "type": "string"
                                        },
                                        "title": "paths"
                                    }
                                },
                                "additionalProperties": false,
                                "required": [
                                    "algorithm",
                                    "paths"
                                ]
                            }
                        ]
                    }
                },
                "additionalProperties": false,
                "required": [
                    "enabled",
                    "if",
                    "name",
                    "sourceId"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listUserGroups (GET /groups)
  {
    name: "listUserGroups",
    description: `Returns all user groups.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Pagination for user groups.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createUserGroup (POST /groups)
  {
    name: "createUserGroup",
    description: `Creates a user group.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* User Group Created
* Policy Created
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Creates a user group, used to bundle permissions for its members, within a Workspace.",
                "title": "CreateUserGroupV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "The name of the user group to create.",
                        "type": "string",
                        "title": "name"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "name"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: createValidationInWarehouse (POST /warehouses/validation)
  {
    name: "createValidationInWarehouse",
    description: `Validates input settings against a Warehouse.



• When called, this endpoint may generate the \`Storage Destination Settings Validation\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Verifies a set of Warehouse credentials by attempting to connect to it.",
                "title": "CreateValidationInWarehouseV1Input",
                "type": "object",
                "properties": {
                    "metadataId": {
                        "description": "The id of the Warehouse metadata type.",
                        "type": "string",
                        "title": "metadataId"
                    },
                    "settings": {
                        "description": "The settings to check.",
                        "title": "settings",
                        "allOf": [
                            {
                                "description": "A key-value object that contains instance-specific Warehouse settings.",
                                "title": "WarehouseSettingsV1",
                                "type": "object",
                                "additionalProperties": {}
                            }
                        ]
                    }
                },
                "additionalProperties": false,
                "required": [
                    "metadataId",
                    "settings"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listWarehouses (GET /warehouses)
  {
    name: "listWarehouses",
    description: `Returns a list of Warehouses.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createWarehouse (POST /warehouses)
  {
    name: "createWarehouse",
    description: `Creates a new Warehouse.



• When called, this endpoint may generate the \`Storage Destination Created\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Create a new Warehouse based on a set of parameters.",
                "title": "CreateWarehouseV1Input",
                "type": "object",
                "properties": {
                    "metadataId": {
                        "description": "The Warehouse metadata to use.",
                        "type": "string",
                        "title": "metadataId"
                    },
                    "name": {
                        "description": "An optional human-readable name for this Warehouse.",
                        "type": "string",
                        "title": "name"
                    },
                    "enabled": {
                        "description": "Enable to allow this Warehouse to receive data. Defaults to true.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "settings": {
                        "description": "A key-value object that contains instance-specific settings for a Warehouse.\n\nDifferent kinds of Warehouses require different settings. The required and optional settings\nfor a Warehouse are described in the `options` object of the associated Warehouse metadata.\n\nYou can find the full list of Warehouse metadata and related settings information in the\n`/catalog/warehouses` endpoint.",
                        "title": "settings",
                        "allOf": [
                            {
                                "description": "A key-value object that contains instance-specific Warehouse settings.",
                                "title": "WarehouseSettingsV1",
                                "type": "object",
                                "additionalProperties": {}
                            }
                        ]
                    },
                    "disconnectAllSources": {
                        "description": "Whether to disconnect all Sources from this Warehouse.",
                        "type": "boolean",
                        "title": "disconnectAllSources"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "metadataId",
                    "settings"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: listWorkspaceRegulations (GET /regulations)
  {
    name: "listWorkspaceRegulations",
    description: `Lists all Workspace-scoped regulations.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "status": {
                "description": "The status on which to filter the returned regulations.\n\nThis parameter exists in v1.",
                "enum": [
                    "FAILED",
                    "FINISHED",
                    "INITIALIZED",
                    "INVALID",
                    "NOT_SUPPORTED",
                    "PARTIAL_SUCCESS",
                    "RUNNING"
                ],
                "type": "string",
                "title": "status"
            },
            "regulationTypes": {
                "description": "The regulation types on which to filter returned regulations.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "enum": [
                        "DELETE_INTERNAL",
                        "DELETE_ONLY",
                        "SUPPRESS_ONLY",
                        "SUPPRESS_WITH_DELETE",
                        "SUPPRESS_WITH_DELETE_INTERNAL",
                        "UNSUPPRESS"
                    ],
                    "type": "string"
                },
                "title": "regulationTypes"
            },
            "pagination": {
                "description": "Pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: createWorkspaceRegulation (POST /regulations)
  {
    name: "createWorkspaceRegulation",
    description: `Creates a Workspace-scoped regulation.



• When called, this endpoint may generate the \`Workspace Regulation Created\` event in the [audit trail](/tag/Audit-Trail).

Config API omitted fields:
- \`attributes\`,
- \`userAgent\`
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "The input to create a Workspace regulation.",
                "title": "CreateWorkspaceRegulationV1Input",
                "type": "object",
                "properties": {
                    "regulationType": {
                        "description": "The regulation type to create.",
                        "enum": [
                            "DELETE_INTERNAL",
                            "DELETE_ONLY",
                            "SUPPRESS_ONLY",
                            "SUPPRESS_WITH_DELETE",
                            "SUPPRESS_WITH_DELETE_INTERNAL",
                            "UNSUPPRESS"
                        ],
                        "type": "string",
                        "title": "regulationType"
                    },
                    "subjectType": {
                        "description": "The subject type. Use `objectId` for Cloud Source regulations.",
                        "enum": [
                            "OBJECT_ID",
                            "USER_ID"
                        ],
                        "type": "string",
                        "title": "subjectType"
                    },
                    "subjectIds": {
                        "description": "The list of `userId` or `objectId` values of the subjects to regulate.\n\nConfig API note: equal to `parent` but allows an array.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "subjectIds"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "regulationType",
                    "subjectIds",
                    "subjectType"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: createWriteKeyForSource (POST /sources/{sourceId}/writekey)
  {
    name: "createWriteKeyForSource",
    description: `Creates a new Write Key for the Source.



• When called, this endpoint may generate the \`Source Modified\` event in the [audit trail](/tag/Audit-Trail).
`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: getDestination (GET /destinations/{destinationId})
  {
    name: "getDestination",
    description: `Returns a Destination by its id.

      Config API omitted fields:
- \`catalogId\`
`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "destinationId"
        ]
    }
  },
  // Tool: deleteDestination (DELETE /destinations/{destinationId})
  {
    name: "deleteDestination",
    description: `Deletes an existing Destination.



• When called, this endpoint may generate the \`Integration Deleted\` event in the [audit trail](/tag/Audit-Trail).

Config API omitted fields:
- \`catalogId\`
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "destinationId"
        ]
    }
  },
  // Tool: updateDestination (PATCH /destinations/{destinationId})
  {
    name: "updateDestination",
    description: `Updates an existing Destination.

**Note**: if you attempt to update read-only settings for your destination you'll encounter the following behavior:

  * If only read-only properties are being updated, the endpoint will return an HTTP 400 error.
  * If there's a mix of writable and read-only properties in the payload, the request will be accepted, the writable properties will be updated and the read-only properties ignored.




• When called, this endpoint may generate the \`Integration Disabled\` event in the [audit trail](/tag/Audit-Trail).

Config API omitted fields:
- \`updateMask\`
         `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates a single Destination by its id.",
                "title": "UpdateDestinationV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "Defines the display name of the Destination.\n\nConfig API note: equal to `displayName`.",
                        "type": [
                            "string",
                            "null"
                        ],
                        "title": "name"
                    },
                    "enabled": {
                        "description": "Whether this Destination should receive data.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "settings": {
                        "description": "An optional object that contains settings for the Destination based on the \"required\" and \"advanced\" settings present\nin the Destination metadata.\n\nConfig API note: equal to `config`.",
                        "type": "object",
                        "additionalProperties": true,
                        "title": "settings"
                    }
                },
                "additionalProperties": false
            }
        },
        "required": [
            "destinationId",
            "requestBody"
        ]
    }
  },
  // Tool: getFilterById (GET /filters/{id})
  {
    name: "getFilterById",
    description: `Gets a filter by id.

• This endpoint is in **Beta** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Space Filters feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "id"
        ]
    }
  },
  // Tool: deleteFilterById (DELETE /filters/{id})
  {
    name: "deleteFilterById",
    description: `Deletes a filter by id.



• This endpoint is in **Beta** testing.  Please submit any feedback by sending an email to friends@segment.com.



• In order to successfully call this endpoint, the specified Workspace needs to have the Space Filters feature enabled. Please reach out to your customer success manager for more information.


• When called, this endpoint may generate the \`Filter Deleted\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "id"
        ]
    }
  },
  // Tool: updateFilterById (PATCH /filters/{id})
  {
    name: "updateFilterById",
    description: `Updates a filter by id and replaces the existing filter.



• This endpoint is in **Beta** testing.  Please submit any feedback by sending an email to friends@segment.com.



• In order to successfully call this endpoint, the specified Workspace needs to have the Space Filters feature enabled. Please reach out to your customer success manager for more information.


• When called, this endpoint may generate the \`Filter Updated\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1beta+json)"
            }
        },
        "required": [
            "id",
            "requestBody"
        ]
    }
  },
  // Tool: getFunction (GET /functions/{functionId})
  {
    name: "getFunction",
    description: `Gets a Function.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "functionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "functionId"
        ]
    }
  },
  // Tool: deleteFunction (DELETE /functions/{functionId})
  {
    name: "deleteFunction",
    description: `Deletes a Function.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "functionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "functionId"
        ]
    }
  },
  // Tool: updateFunction (PATCH /functions/{functionId})
  {
    name: "updateFunction",
    description: `Updates a Function.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.

Config API omitted fields:
- \`updateMask\`
`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "functionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Update a Function.",
                "title": "UpdateFunctionV1Input",
                "type": "object",
                "properties": {
                    "code": {
                        "description": "The Function code.",
                        "type": "string",
                        "title": "code"
                    },
                    "settings": {
                        "description": "The list of settings for this Function.",
                        "type": "array",
                        "items": {
                            "title": "FunctionSettingV1",
                            "type": "object",
                            "properties": {
                                "name": {
                                    "description": "The name of this Function Setting.",
                                    "type": "string",
                                    "title": "name"
                                },
                                "label": {
                                    "description": "The label for this Function Setting.",
                                    "type": "string",
                                    "title": "label"
                                },
                                "description": {
                                    "description": "A description of this Function Setting.",
                                    "type": "string",
                                    "title": "description"
                                },
                                "type": {
                                    "description": "The type of this Function Setting.",
                                    "enum": [
                                        "ARRAY",
                                        "BOOLEAN",
                                        "STRING",
                                        "TEXT_MAP"
                                    ],
                                    "type": "string",
                                    "title": "type"
                                },
                                "required": {
                                    "description": "Whether this Function Setting is required.",
                                    "type": "boolean",
                                    "title": "required"
                                },
                                "sensitive": {
                                    "description": "Whether this Function Setting contains sensitive information.",
                                    "type": "boolean",
                                    "title": "sensitive"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "description",
                                "label",
                                "name",
                                "required",
                                "sensitive",
                                "type"
                            ]
                        },
                        "title": "settings"
                    },
                    "displayName": {
                        "description": "A display name for this Function.",
                        "type": "string",
                        "title": "displayName"
                    },
                    "logoUrl": {
                        "description": "A logo for this Function.",
                        "type": "string",
                        "title": "logoUrl"
                    },
                    "description": {
                        "description": "A description for this Function.",
                        "type": "string",
                        "title": "description"
                    }
                },
                "additionalProperties": false
            }
        },
        "required": [
            "functionId",
            "requestBody"
        ]
    }
  },
  // Tool: getInsertFunctionInstance (GET /insert-function-instances/{instanceId})
  {
    name: "getInsertFunctionInstance",
    description: `Gets an insert Function instance.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "instanceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "instanceId"
        ]
    }
  },
  // Tool: deleteInsertFunctionInstance (DELETE /insert-function-instances/{instanceId})
  {
    name: "deleteInsertFunctionInstance",
    description: `Deletes an insert Function instance.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "instanceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "instanceId"
        ]
    }
  },
  // Tool: updateInsertFunctionInstance (PATCH /insert-function-instances/{instanceId})
  {
    name: "updateInsertFunctionInstance",
    description: `Updates an insert Function instance connected to the given Destination.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "instanceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "instanceId",
            "requestBody"
        ]
    }
  },
  // Tool: deleteLabel (DELETE /labels/{key}/{value})
  {
    name: "deleteLabel",
    description: `Deletes a label.



• When called, this endpoint may generate the \`Label Deleted\` event in the [audit trail](/tag/Audit-Trail).
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "key": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "value": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "key",
            "value"
        ]
    }
  },
  // Tool: getRegulation (GET /regulations/{regulateId})
  {
    name: "getRegulation",
    description: `Gets a regulation from the Workspace.

      Config API omitted fields:
- \`parent\`
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "regulateId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "regulateId"
        ]
    }
  },
  // Tool: deleteRegulation (DELETE /regulations/{regulateId})
  {
    name: "deleteRegulation",
    description: `Deletes a regulation from the Workspace. The regulation must be in the initialized state to be deleted.



• When called, this endpoint may generate the \`Regulation Deleted\` event in the [audit trail](/tag/Audit-Trail).
      

**DEPRECATED**: this endpoint has been deprecated according to the guidelines, and may experience reduced SLA guarantees.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "regulateId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "regulateId"
        ]
    }
  },
  // Tool: getReverseEtlModel (GET /reverse-etl-models/{modelId})
  {
    name: "getReverseEtlModel",
    description: `Returns a Reverse ETL Model by its id.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "modelId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "modelId"
        ]
    }
  },
  // Tool: deleteReverseEtlModel (DELETE /reverse-etl-models/{modelId})
  {
    name: "deleteReverseEtlModel",
    description: `Deletes an existing Model.

      

• When called, this endpoint may generate the \`Model Deleted\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "modelId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "modelId"
        ]
    }
  },
  // Tool: updateReverseEtlModel (PATCH /reverse-etl-models/{modelId})
  {
    name: "updateReverseEtlModel",
    description: `Updates an existing Reverse ETL Model.

      

• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Model Settings Saved
* Model State Change Toggled
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "modelId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "modelId",
            "requestBody"
        ]
    }
  },
  // Tool: getSource (GET /sources/{sourceId})
  {
    name: "getSource",
    description: `Returns a Source by its id.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: deleteSource (DELETE /sources/{sourceId})
  {
    name: "deleteSource",
    description: `Deletes an existing Source.



• When called, this endpoint may generate the \`Source Deleted\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: updateSource (PATCH /sources/{sourceId})
  {
    name: "updateSource",
    description: `Updates an existing Source.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Source Modified
* Source Enabled
* Source Settings Modified
* Source Disabled

Config API omitted fields:
- \`updateMask\`
`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates an existing Source based on a set of parameters.",
                "title": "UpdateSourceV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "An optional human-readable name to associate with the Source.\n\nConfig API note: equal to `displayName`.",
                        "type": "string",
                        "title": "name"
                    },
                    "enabled": {
                        "description": "Enable to allow the Source to send data.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "slug": {
                        "description": "The slug that identifies the Source.\n\nConfig API note: equal to `name`.",
                        "type": "string",
                        "title": "slug"
                    },
                    "settings": {
                        "description": "A key-value object that contains instance-specific settings for the Source.\n\nDifferent kinds of Sources require different kinds of input. The settings input for a Source comes from the\n`options` object associated with this instance of a Source.\n\nYou can find the full list of required settings by accessing the Sources catalog endpoint under `/catalog/sources`.",
                        "title": "settings",
                        "allOf": [
                            {
                                "description": "A key-value object that contains instance-specific settings for a Source.\n\nThe `options` field in the Source metadata defines the schema of this object.",
                                "title": "SourceSettingsV1",
                                "type": "object",
                                "additionalProperties": {}
                            }
                        ]
                    }
                },
                "additionalProperties": false
            }
        },
        "required": [
            "sourceId",
            "requestBody"
        ]
    }
  },
  // Tool: getTrackingPlan (GET /tracking-plans/{trackingPlanId})
  {
    name: "getTrackingPlan",
    description: `Returns a Tracking Plan.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "trackingPlanId"
        ]
    }
  },
  // Tool: deleteTrackingPlan (DELETE /tracking-plans/{trackingPlanId})
  {
    name: "deleteTrackingPlan",
    description: `Deletes a Tracking Plan.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "trackingPlanId"
        ]
    }
  },
  // Tool: updateTrackingPlan (PATCH /tracking-plans/{trackingPlanId})
  {
    name: "updateTrackingPlan",
    description: `Updates a Tracking Plan.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.

Config API omitted fields:
- \`updateMask\`
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates the Workspace's Tracking Plan.",
                "title": "UpdateTrackingPlanV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "The Tracking Plan's name.\n\nConfig API note: equal to `displayName`.",
                        "type": "string",
                        "title": "name"
                    },
                    "description": {
                        "description": "The Tracking Plan's description.",
                        "type": "string",
                        "title": "description"
                    }
                },
                "additionalProperties": false
            }
        },
        "required": [
            "trackingPlanId",
            "requestBody"
        ]
    }
  },
  // Tool: getTransformation (GET /transformations/{transformationId})
  {
    name: "getTransformation",
    description: `Gets a Transformation.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "transformationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "transformationId"
        ]
    }
  },
  // Tool: deleteTransformation (DELETE /transformations/{transformationId})
  {
    name: "deleteTransformation",
    description: `Deletes a Transformation.



• When called, this endpoint may generate the \`Transformation Deleted\` event in the [audit trail](/tag/Audit-Trail).


• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "transformationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "transformationId"
        ]
    }
  },
  // Tool: updateTransformation (PATCH /transformations/{transformationId})
  {
    name: "updateTransformation",
    description: `Updates an existing Transformation.



• When called, this endpoint may generate the \`Transformation Updated\` event in the [audit trail](/tag/Audit-Trail).


• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "transformationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "The input to update a Transformation.",
                "title": "UpdateTransformationV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "The name of the Transformation.",
                        "type": "string",
                        "title": "name"
                    },
                    "sourceId": {
                        "description": "The optional Source to be associated with the Transformation.",
                        "type": "string",
                        "title": "sourceId"
                    },
                    "destinationMetadataId": {
                        "description": "The optional Destination metadata to be associated with the Transformation.",
                        "type": "string",
                        "title": "destinationMetadataId"
                    },
                    "enabled": {
                        "description": "If the Transformation should be enabled.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "if": {
                        "description": "If statement ([FQL](https://segment.com/docs/config-api/fql/)) to match events.\n\nFor standard event matchers, use the following:\n Track -\\> \"event='\\<eventName\\>'\"\n Identify -\\> \"type='identify'\"\n Group -\\> \"type='group'\"",
                        "type": "string",
                        "title": "if"
                    },
                    "drop": {
                        "description": "Optional boolean value if the Transformation should drop the event entirely when the if statement matches, ignores all other transforms.",
                        "type": "boolean",
                        "title": "drop"
                    },
                    "newEventName": {
                        "description": "Optional new event name for renaming events. Works only for 'track' event type.",
                        "type": "string",
                        "title": "newEventName"
                    },
                    "propertyRenames": {
                        "description": "Optional array for renaming properties collected by your events.",
                        "type": "array",
                        "items": {
                            "title": "PropertyRenameV1",
                            "type": "object",
                            "properties": {
                                "oldName": {
                                    "description": "The old name of the property.",
                                    "type": "string",
                                    "title": "oldName"
                                },
                                "newName": {
                                    "description": "The new name to rename the property.",
                                    "type": "string",
                                    "title": "newName"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "newName",
                                "oldName"
                            ]
                        },
                        "title": "propertyRenames"
                    },
                    "propertyValueTransformations": {
                        "description": "Optional array for transforming properties and values collected by your events. Limited to 10 properties.",
                        "type": "array",
                        "items": {
                            "title": "PropertyValueTransformationV1",
                            "type": "object",
                            "properties": {
                                "propertyPaths": {
                                    "description": "The property paths. The maximum number of paths is 10.",
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    },
                                    "title": "propertyPaths"
                                },
                                "propertyValue": {
                                    "description": "The new value of the property paths.",
                                    "type": "string",
                                    "title": "propertyValue"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "propertyPaths",
                                "propertyValue"
                            ]
                        },
                        "title": "propertyValueTransformations"
                    },
                    "fqlDefinedProperties": {
                        "description": "Optional array for updating properties defined in [FQL](https://segment.com/docs/config-api/fql/). Currently limited to 1 property.",
                        "type": "array",
                        "items": {
                            "title": "FQLDefinedPropertyV1",
                            "type": "object",
                            "properties": {
                                "fql": {
                                    "description": "The FQL expression used to compute the property.",
                                    "type": "string",
                                    "title": "fql"
                                },
                                "propertyName": {
                                    "description": "The new property name.",
                                    "type": "string",
                                    "title": "propertyName"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "fql",
                                "propertyName"
                            ]
                        },
                        "title": "fqlDefinedProperties"
                    },
                    "allowProperties": {
                        "description": "Optional array for allowing properties from your events.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "allowProperties"
                    },
                    "hashPropertiesConfiguration": {
                        "description": "Optional object for hashing properties within an event.",
                        "title": "hashPropertiesConfiguration",
                        "allOf": [
                            {
                                "title": "HashPropertiesConfiguration",
                                "type": "object",
                                "properties": {
                                    "algorithm": {
                                        "description": "Which algorithm to use to hash to properties.",
                                        "type": "string",
                                        "title": "algorithm"
                                    },
                                    "key": {
                                        "description": "Optional key to hash with.",
                                        "type": "string",
                                        "title": "key"
                                    },
                                    "encoding": {
                                        "description": "Optional encoding to use for the hashing.",
                                        "enum": [
                                            "BASE16",
                                            "BASE64",
                                            "BASE64URL",
                                            "HEX"
                                        ],
                                        "type": "string",
                                        "title": "encoding"
                                    },
                                    "paths": {
                                        "description": "The paths to the properties to be hashed.",
                                        "type": "array",
                                        "items": {
                                            "type": "string"
                                        },
                                        "title": "paths"
                                    }
                                },
                                "additionalProperties": false,
                                "required": [
                                    "algorithm",
                                    "paths"
                                ]
                            }
                        ]
                    }
                },
                "additionalProperties": false
            }
        },
        "required": [
            "transformationId",
            "requestBody"
        ]
    }
  },
  // Tool: getUserGroup (GET /groups/{userGroupId})
  {
    name: "getUserGroup",
    description: `Returns a user group.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "userGroupId"
        ]
    }
  },
  // Tool: deleteUserGroup (DELETE /groups/{userGroupId})
  {
    name: "deleteUserGroup",
    description: `Removes a user group from a Workspace.



• When called, this endpoint may generate the \`User Group Deleted\` event in the [audit trail](/tag/Audit-Trail).
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "userGroupId"
        ]
    }
  },
  // Tool: updateUserGroup (PATCH /groups/{userGroupId})
  {
    name: "updateUserGroup",
    description: `Updates a user group for a Workspace.



• When called, this endpoint may generate the \`User Group Updated\` event in the [audit trail](/tag/Audit-Trail).
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates a user group with a given id.",
                "title": "UpdateUserGroupV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "The intended value to rename the user group to.",
                        "type": "string",
                        "title": "name"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "name"
                ]
            }
        },
        "required": [
            "userGroupId",
            "requestBody"
        ]
    }
  },
  // Tool: listUsers (GET /users)
  {
    name: "listUsers",
    description: `Returns a list of users with access to the Workspace.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Pagination for users.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: deleteUsers (DELETE /users)
  {
    name: "deleteUsers",
    description: `Removes one or multiple users.



• When called, this endpoint may generate the \`Group Memberships Deleted\` event in the [audit trail](/tag/Audit-Trail).
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userIds": {
                "description": "The ids of the users to remove.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "userIds"
            }
        },
        "required": [
            "userIds"
        ]
    }
  },
  // Tool: getWarehouse (GET /warehouses/{warehouseId})
  {
    name: "getWarehouse",
    description: `Returns a Warehouse by its id.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "warehouseId"
        ]
    }
  },
  // Tool: deleteWarehouse (DELETE /warehouses/{warehouseId})
  {
    name: "deleteWarehouse",
    description: `Deletes an existing Warehouse.



• When called, this endpoint may generate the \`Storage Destination Deleted\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "warehouseId"
        ]
    }
  },
  // Tool: updateWarehouse (PATCH /warehouses/{warehouseId})
  {
    name: "updateWarehouse",
    description: `Updates an existing Warehouse.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Storage Destination Modified
* Storage Destination Enabled
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates an existing Warehouse based on a set of parameters.",
                "title": "UpdateWarehouseV1Input",
                "type": "object",
                "properties": {
                    "name": {
                        "description": "An optional human-readable name to associate with this Warehouse.",
                        "type": [
                            "string",
                            "null"
                        ],
                        "title": "name"
                    },
                    "enabled": {
                        "description": "Enable to allow this Warehouse to receive data.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "settings": {
                        "description": "A key-value object that contains instance-specific settings for a Warehouse.\n\nDifferent kinds of Warehouses require different settings. The required and optional settings\nfor a Warehouse are described in the `options` object of the associated Warehouse metadata.\n\nYou can find the full list of Warehouse metadata and related settings information in the\n`/catalog/warehouses` endpoint.",
                        "title": "settings",
                        "allOf": [
                            {
                                "description": "A key-value object that contains instance-specific Warehouse settings.",
                                "title": "WarehouseSettingsV1",
                                "type": "object",
                                "additionalProperties": {}
                            }
                        ]
                    }
                },
                "additionalProperties": false,
                "required": [
                    "settings"
                ]
            }
        },
        "required": [
            "warehouseId",
            "requestBody"
        ]
    }
  },
  // Tool: disableEdgeFunctions (PATCH /sources/{sourceId}/edge-functions/disable)
  {
    name: "disableEdgeFunctions",
    description: `Disable Edge Functions for your Source.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Edge Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: echo (GET /echo)
  {
    name: "echo",
    description: `Public Echo endpoint.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "message": {
                "description": "Sets the response `message` field. The response contains this field's entry.\n\nThis parameter exists in alpha.",
                "type": "string",
                "title": "message"
            },
            "delay": {
                "description": "The desired response delay, in milliseconds.\n\nThis parameter exists in alpha.",
                "type": "number",
                "title": "delay"
            },
            "triggerError": {
                "description": "If `true`, returns an HTTP `4xx` error that contains the string in `message`.\n\nThis parameter exists in alpha.",
                "type": "boolean",
                "title": "triggerError"
            },
            "triggerMultipleErrors": {
                "description": "If `true`, returns an HTTP `4xx` error that contains the value of the `message` field in the error message array.\n\nThis has no effect if the request sets `triggerError`.\n\nThis parameter exists in alpha.",
                "type": "boolean",
                "title": "triggerMultipleErrors"
            },
            "triggerUnexpectedError": {
                "description": "If `true`, triggers a `500` error.\n\nThis has no effect if the request sets either `triggerError` or `triggerMultipleErrors`.\n\nThis parameter exists in alpha.",
                "type": "boolean",
                "title": "triggerUnexpectedError"
            },
            "statusCode": {
                "description": "Sets the HTTP status code to return.\n\nThis parameter exists in alpha.",
                "type": "number",
                "title": "statusCode"
            }
        },
        "required": [
            "message"
        ]
    }
  },
  // Tool: generateUploadURLForEdgeFunctions (POST /sources/{sourceId}/edge-functions/upload-url)
  {
    name: "generateUploadURLForEdgeFunctions",
    description: `Generate a temporary upload URL that can be used to upload an Edge Functions bundle.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Edge Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: getActivationFromAudience (GET /spaces/{spaceId}/audiences/{audienceId}/activations/{id})
  {
    name: "getActivationFromAudience",
    description: `Gets a single Activation by id.


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "audienceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "workspaceId": {
                "description": "The workspace id\n\nThis parameter exists in alpha.",
                "type": "string",
                "title": "workspaceId"
            }
        },
        "required": [
            "spaceId",
            "audienceId",
            "id",
            "workspaceId"
        ]
    }
  },
  // Tool: removeActivationFromAudience (DELETE /spaces/{spaceId}/audiences/{audienceId}/activations/{id})
  {
    name: "removeActivationFromAudience",
    description: `Deletes an Activation.


The rate limit for this endpoint is 10 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "audienceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "workspaceId": {
                "description": "The workspace id\n\nThis parameter exists in alpha.",
                "type": "string",
                "title": "workspaceId"
            }
        },
        "required": [
            "spaceId",
            "audienceId",
            "id",
            "workspaceId"
        ]
    }
  },
  // Tool: updateActivationForAudience (PATCH /spaces/{spaceId}/audiences/{audienceId}/activations/{id})
  {
    name: "updateActivationForAudience",
    description: `Updates an Activation.


The rate limit for this endpoint is 10 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "audienceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "audienceId",
            "id",
            "requestBody"
        ]
    }
  },
  // Tool: getAdvancedSyncScheduleFromWarehouse (GET /warehouses/{warehouseId}/advanced-sync-schedule)
  {
    name: "getAdvancedSyncScheduleFromWarehouse",
    description: `Returns the advanced sync schedule for a Warehouse.


The rate limit for this endpoint is 2 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "warehouseId"
        ]
    }
  },
  // Tool: replaceAdvancedSyncScheduleForWarehouse (PUT /warehouses/{warehouseId}/advanced-sync-schedule)
  {
    name: "replaceAdvancedSyncScheduleForWarehouse",
    description: `Updates the advanced sync schedule for a Warehouse, replacing the sync schedule with a new schedule.


The rate limit for this endpoint is 2 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Replaces the advanced sync schedule for a Warehouse.",
                "title": "ReplaceAdvancedSyncScheduleForWarehouseV1Input",
                "type": "object",
                "properties": {
                    "enabled": {
                        "description": "Enable to turn on an advanced sync schedule for the Warehouse.",
                        "type": "boolean",
                        "title": "enabled"
                    },
                    "schedule": {
                        "description": "The full sync schedule for the Warehouse.",
                        "title": "schedule",
                        "allOf": [
                            {
                                "description": "Defines the advanced sync schedule for a Warehouse.",
                                "title": "AdvancedWarehouseSyncScheduleV1Input",
                                "type": "object",
                                "properties": {
                                    "times": {
                                        "description": "A list that contains the times when syncs should occur.",
                                        "type": "array",
                                        "items": {
                                            "description": "Determines the time of day at which a Warehouse should sync.",
                                            "title": "WarehouseAdvancedSyncV1",
                                            "type": "object",
                                            "properties": {
                                                "hourOfDay": {
                                                    "description": "The hour of day for which to enable/disable a sync, between 0 and 23.",
                                                    "type": "number",
                                                    "title": "hourOfDay"
                                                },
                                                "enabled": {
                                                    "description": "Enable to the sync at the specified hour.",
                                                    "type": "boolean",
                                                    "title": "enabled"
                                                }
                                            },
                                            "additionalProperties": false,
                                            "required": [
                                                "enabled",
                                                "hourOfDay"
                                            ]
                                        },
                                        "title": "times"
                                    },
                                    "timezone": {
                                        "description": "A TZ-database timezone for this sync schedule.",
                                        "type": "string",
                                        "title": "timezone"
                                    }
                                },
                                "additionalProperties": false,
                                "required": [
                                    "times",
                                    "timezone"
                                ]
                            }
                        ]
                    }
                },
                "additionalProperties": false,
                "required": [
                    "enabled"
                ]
            }
        },
        "required": [
            "warehouseId",
            "requestBody"
        ]
    }
  },
  // Tool: getAudience (GET /spaces/{spaceId}/audiences/{id})
  {
    name: "getAudience",
    description: `Returns the Audience by id and spaceId. Supports including audience schedules via \`?include=schedules\`.

• This endpoint is in **Beta** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 100 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "include": {
                "description": "Additional resource to include, support schedules only.\n\nThis parameter exists in alpha.",
                "enum": [
                    "schedules"
                ],
                "type": "string",
                "title": "include"
            }
        },
        "required": [
            "spaceId",
            "id"
        ]
    }
  },
  // Tool: removeAudienceFromSpace (DELETE /spaces/{spaceId}/audiences/{id})
  {
    name: "removeAudienceFromSpace",
    description: `Deletes an Audience by id and spaceId.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Audience Deleted\` event in the [audit trail](/tag/Audit-Trail).


The rate limit for this endpoint is 20 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "spaceId",
            "id"
        ]
    }
  },
  // Tool: updateAudienceForSpace (PATCH /spaces/{spaceId}/audiences/{id})
  {
    name: "updateAudienceForSpace",
    description: `Updates the Audience.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Audience Modified\` event in the [audit trail](/tag/Audit-Trail).

• Note that when an Audience is updated, the Audience will be locked from future edits until the changes have been incorporated. You can find more information [in the Segment docs](https://segment-docs.netlify.app/docs/engage/audiences/#editing-realtime-audiences-and-traits).
 Note: The definition for an Audience updated using the API is not editable through the Segment App.


The rate limit for this endpoint is 10 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "id",
            "requestBody"
        ]
    }
  },
  // Tool: getAudiencePreview (GET /spaces/{spaceId}/audiences/previews/{id})
  {
    name: "getAudiencePreview",
    description: `Reads the results of an audience preview.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 100 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "spaceId",
            "id"
        ]
    }
  },
  // Tool: getAudienceScheduleFromSpaceAndAudience (GET /spaces/{spaceId}/audiences/{id}/schedules/{scheduleId})
  {
    name: "getAudienceScheduleFromSpaceAndAudience",
    description: `Returns the schedule for the given audience and scheduleId.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "scheduleId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "spaceId",
            "id",
            "scheduleId"
        ]
    }
  },
  // Tool: getComputedTrait (GET /spaces/{spaceId}/computed-traits/{id})
  {
    name: "getComputedTrait",
    description: `Returns the Computed Trait by id and spaceId

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Computed Trait feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 100 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "spaceId",
            "id"
        ]
    }
  },
  // Tool: removeComputedTraitFromSpace (DELETE /spaces/{spaceId}/computed-traits/{id})
  {
    name: "removeComputedTraitFromSpace",
    description: `Deletes a Computed Trait by id and spaceId.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Computed Trait feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Computed Trait Deleted\` event in the [audit trail](/tag/Audit-Trail).


The rate limit for this endpoint is 20 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "spaceId",
            "id"
        ]
    }
  },
  // Tool: updateComputedTraitForSpace (PATCH /spaces/{spaceId}/computed-traits/{id})
  {
    name: "updateComputedTraitForSpace",
    description: `Updates the Computed Trait.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Computed Trait feature enabled. Please reach out to your customer success manager for more information.

• When called, this endpoint may generate the \`Computed Trait Modified\` event in the [audit trail](/tag/Audit-Trail).

• Note that when a Computed Trait is updated, the Computed Trait will be locked from future edits until the changes have been incorporated. You can find more information [in the Segment docs](https://segment-docs.netlify.app/docs/unify/traits/computed-traits/#editing-realtime-traits).
 Note: The definition for a Computed Trait updated using the API is not editable through the Segment App.


The rate limit for this endpoint is 10 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "id",
            "requestBody"
        ]
    }
  },
  // Tool: getConnectionStateFromWarehouse (GET /warehouses/{warehouseId}/connection-state)
  {
    name: "getConnectionStateFromWarehouse",
    description: `Verifies the state of Warehouse connection settings.


The rate limit for this endpoint is 200 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "warehouseId"
        ]
    }
  },
  // Tool: getDailyPerSourceAPICallsUsage (GET /usage/api-calls/sources/daily)
  {
    name: "getDailyPerSourceAPICallsUsage",
    description: `Provides daily cumulative per-source API call counts for a usage period.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "period": {
                "description": "The start of the usage month in the ISO-8601 format.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "period"
            },
            "pagination": {
                "description": "Pagination input for per Source API calls counts.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "period"
        ]
    }
  },
  // Tool: getDailyPerSourceMTUUsage (GET /usage/mtu/sources/daily)
  {
    name: "getDailyPerSourceMTUUsage",
    description: `Provides daily cumulative per-source MTU counts for a usage period.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "period": {
                "description": "The start of the usage month, in the ISO-8601 format.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "period"
            },
            "pagination": {
                "description": "Pagination input for per Source MTU counts.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "period"
        ]
    }
  },
  // Tool: getDailyWorkspaceAPICallsUsage (GET /usage/api-calls/daily)
  {
    name: "getDailyWorkspaceAPICallsUsage",
    description: `Provides daily cumulative API call counts for a usage period.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "period": {
                "description": "The start of the usage month in the ISO-8601 format.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "period"
            },
            "pagination": {
                "description": "Pagination input for Workspace API call counts.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "period"
        ]
    }
  },
  // Tool: getDailyWorkspaceMTUUsage (GET /usage/mtu/daily)
  {
    name: "getDailyWorkspaceMTUUsage",
    description: `Provides daily cumulative MTU counts for a usage period.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "period": {
                "description": "The start of the usage month, in the ISO-8601 format.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "period"
            },
            "pagination": {
                "description": "Pagination input for Workspace MTU counts.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "period"
        ]
    }
  },
  // Tool: getDestinationMetadata (GET /catalog/destinations/{destinationMetadataId})
  {
    name: "getDestinationMetadata",
    description: `Returns a Destination catalog item by its id.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationMetadataId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "destinationMetadataId"
        ]
    }
  },
  // Tool: getDestinationsCatalog (GET /catalog/destinations)
  {
    name: "getDestinationsCatalog",
    description: `Returns a list of all available Destinations in the Segment catalog.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Required pagination parameters used to filter the Destinations catalog.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: getEgressFailedMetricsFromDeliveryOverview (GET /delivery-overview/failed-delivery)
  {
    name: "getEgressFailedMetricsFromDeliveryOverview",
    description: `Get events that failed to be delivered to Destination.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "description": "The sourceId for the Workspace.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "sourceId"
            },
            "destinationConfigId": {
                "description": "The id tied to a Workspace Destination.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "destinationConfigId"
            },
            "startTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nbeginning of the requested time frame, inclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nend of the requested time frame, noninclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "endTime"
            },
            "groupBy": {
                "description": "A comma-delimited list of strings representing one or more dimensions\nto group the result by.  Valid options are:\n`event Name`, `event Type`, `discard Reason`, `app Version`, `subscription Id`, `activationId`, `audienceId`, and `spaceId`.\n\nThis parameter exists in beta.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "groupBy"
            },
            "granularity": {
                "description": "The size of each bucket in the requested window.\n\nBased on the granularity chosen, there are restrictions on the time range you can query:\n\n**Minute**:\n- Max time range: 4 hours\n- Oldest possible start time: 48 hours in the past\n\n**Hour**:\n- Max Time range: 14 days\n- Oldest possible start time: 30 days in the past\n\n**Day**:\n- Max time range: 30 days\n- Oldest possible start time: 30 days in the past\n\nThis parameter exists in beta.",
                "enum": [
                    "DAY",
                    "HOUR",
                    "MINUTE"
                ],
                "type": "string",
                "title": "granularity"
            },
            "filter": {
                "description": "An optional filter for `event Name`, `event Type`, `discard Reason`, `app Version`, `subscription Id`, `activationId`, `audienceId`, and/or `spaceId` that can be applied in addition to a `group By`.\n\nThis parameter exists in beta.",
                "title": "DeliveryOverviewDestinationFilterBy",
                "type": "object",
                "properties": {
                    "discardReason": {
                        "description": "A list of strings of discard reasons.\n\nSee [Discard Record Documentation](https://segment.com/docs/connections/delivery-overview/#troubleshooting) for valid error codes.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "discardReason"
                    },
                    "eventName": {
                        "description": "A list of strings of event names.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventName"
                    },
                    "eventType": {
                        "description": "A list of strings of event types.\nValid options are: `alias`, `group`, `identify`, `page`, `screen`, and `track`.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventType"
                    },
                    "appVersion": {
                        "description": "A list of strings of app versions.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "appVersion"
                    },
                    "subscriptionId": {
                        "description": "A list of strings of subscription IDs for Actions Destinations.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "subscriptionId"
                    },
                    "activationId": {
                        "description": "A list of strings of event context IDs from a Linked Audience mapping/activation.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "activationId"
                    },
                    "audienceId": {
                        "description": "A list of strings of audience IDs for a Linked Audience.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "audienceId"
                    },
                    "spaceId": {
                        "description": "A list of strings of space IDs for a Linked Audience.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "spaceId"
                    }
                },
                "additionalProperties": false
            },
            "pagination": {
                "description": "Params to specify the page cursor and count.\n\nThis parameter exists in beta.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId",
            "destinationConfigId",
            "startTime",
            "endTime",
            "granularity"
        ]
    }
  },
  // Tool: getEgressSuccessMetricsFromDeliveryOverview (GET /delivery-overview/successful-delivery)
  {
    name: "getEgressSuccessMetricsFromDeliveryOverview",
    description: `Get events successfully delivered to Destination.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "description": "The sourceId for the Workspace.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "sourceId"
            },
            "destinationConfigId": {
                "description": "The id tied to a Workspace Destination.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "destinationConfigId"
            },
            "startTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nbeginning of the requested time frame, inclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nend of the requested time frame, noninclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "endTime"
            },
            "groupBy": {
                "description": "A comma-delimited list of strings representing one or more dimensions\nto group the result by.  Valid options are:\n`event Name`, `event Type`, `discard Reason`, `app Version`, `subscription Id`, `activationId`, `audienceId`, and `spaceId`.\n\nThis parameter exists in beta.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "groupBy"
            },
            "granularity": {
                "description": "The size of each bucket in the requested window.\n\nBased on the granularity chosen, there are restrictions on the time range you can query:\n\n**Minute**:\n- Max time range: 4 hours\n- Oldest possible start time: 48 hours in the past\n\n**Hour**:\n- Max Time range: 14 days\n- Oldest possible start time: 30 days in the past\n\n**Day**:\n- Max time range: 30 days\n- Oldest possible start time: 30 days in the past\n\nThis parameter exists in beta.",
                "enum": [
                    "DAY",
                    "HOUR",
                    "MINUTE"
                ],
                "type": "string",
                "title": "granularity"
            },
            "filter": {
                "description": "An optional filter for `event Name`, `event Type`, `discard Reason`, `appVersion`, `subscription Id`, `activationId`, `audienceId`, or `spaceId` that can be applied in addition to a `group By`.\nIf you would like to view retry attempts for a successful delivery, you can filter `discard Reason` from `successes.attempt.1` through `successes.attempt.10`.\n\nThis parameter exists in beta.",
                "title": "DeliveryOverviewDestinationFilterBy",
                "type": "object",
                "properties": {
                    "discardReason": {
                        "description": "A list of strings of discard reasons.\n\nSee [Discard Record Documentation](https://segment.com/docs/connections/delivery-overview/#troubleshooting) for valid error codes.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "discardReason"
                    },
                    "eventName": {
                        "description": "A list of strings of event names.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventName"
                    },
                    "eventType": {
                        "description": "A list of strings of event types.\nValid options are: `alias`, `group`, `identify`, `page`, `screen`, and `track`.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventType"
                    },
                    "appVersion": {
                        "description": "A list of strings of app versions.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "appVersion"
                    },
                    "subscriptionId": {
                        "description": "A list of strings of subscription IDs for Actions Destinations.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "subscriptionId"
                    },
                    "activationId": {
                        "description": "A list of strings of event context IDs from a Linked Audience mapping/activation.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "activationId"
                    },
                    "audienceId": {
                        "description": "A list of strings of audience IDs for a Linked Audience.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "audienceId"
                    },
                    "spaceId": {
                        "description": "A list of strings of space IDs for a Linked Audience.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "spaceId"
                    }
                },
                "additionalProperties": false
            },
            "pagination": {
                "description": "Params to specify the page cursor and count.\n\nThis parameter exists in beta.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId",
            "destinationConfigId",
            "startTime",
            "endTime",
            "granularity"
        ]
    }
  },
  // Tool: getEventsVolumeFromWorkspace (GET /events/volume)
  {
    name: "getEventsVolumeFromWorkspace",
    description: `Enumerates the Workspace event volumes over time in minute increments.


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "granularity": {
                "description": "The size of each bucket in the requested window.\n\nThis parameter exists in v1.",
                "enum": [
                    "DAY",
                    "HOUR",
                    "MINUTE"
                ],
                "type": "string",
                "title": "granularity"
            },
            "startTime": {
                "description": "The ISO8601 formatted timestamp that corresponds to the\nbeginning of the requested time frame, inclusive.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "The ISO8601 formatted timestamp that corresponds to the\nend of the requested time frame, noninclusive.\nSegment recommends that you lag queries 1 minute behind clock time to reduce\nthe risk for latency to impact the counts.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "endTime"
            },
            "groupBy": {
                "description": "A comma-delimited list of strings that represents the dimensions\nto group the result by. The options are:\n`eventName`, `eventType` and `source`.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "groupBy"
            },
            "sourceId": {
                "description": "A list of strings which filters the results to the given\nSourceIds.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "sourceId"
            },
            "eventName": {
                "description": "A list of strings which filters the results to the given\nEventNames.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "eventName"
            },
            "eventType": {
                "description": "A list of strings which filters the results to the given\nEventTypes.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "eventType"
            },
            "appVersion": {
                "description": "A list of strings which filters the results to the given\nAppVersions.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "appVersion"
            },
            "pagination": {
                "description": "Pagination input for event volume by Workspace.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "granularity",
            "startTime",
            "endTime"
        ]
    }
  },
  // Tool: getFilteredAtDestinationMetricsFromDeliveryOverview (GET /delivery-overview/filtered-at-destination)
  {
    name: "getFilteredAtDestinationMetricsFromDeliveryOverview",
    description: `Get events that were filtered at Destination.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "description": "The sourceId for the Workspace.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "sourceId"
            },
            "destinationConfigId": {
                "description": "The id tied to a Workspace Destination.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "destinationConfigId"
            },
            "startTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nbeginning of the requested time frame, inclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nend of the requested time frame, noninclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "endTime"
            },
            "groupBy": {
                "description": "A comma-delimited list of strings representing one or more dimensions\nto group the result by.  Valid options are:\n`event Name`, `event Type`, `discard Reason`, `app Version`, `subscription Id`, `activationId`, `audienceId`, and `spaceId`.\n\nThis parameter exists in beta.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "groupBy"
            },
            "granularity": {
                "description": "The size of each bucket in the requested window.\n\nBased on the granularity chosen, there are restrictions on the time range you can query:\n\n**Minute**:\n- Max time range: 4 hours\n- Oldest possible start time: 48 hours in the past\n\n**Hour**:\n- Max Time range: 14 days\n- Oldest possible start time: 30 days in the past\n\n**Day**:\n- Max time range: 30 days\n- Oldest possible start time: 30 days in the past\n\nThis parameter exists in beta.",
                "enum": [
                    "DAY",
                    "HOUR",
                    "MINUTE"
                ],
                "type": "string",
                "title": "granularity"
            },
            "filter": {
                "description": "An optional filter for `event Name`, `event Type`, `discard Reason`, `app Version`, `subscription Id`, `activationId`, `audienceId`, and/or `spaceId` that can be applied in addition to a `group By`.\n\nThis parameter exists in beta.",
                "title": "DeliveryOverviewDestinationFilterBy",
                "type": "object",
                "properties": {
                    "discardReason": {
                        "description": "A list of strings of discard reasons.\n\nSee [Discard Record Documentation](https://segment.com/docs/connections/delivery-overview/#troubleshooting) for valid error codes.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "discardReason"
                    },
                    "eventName": {
                        "description": "A list of strings of event names.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventName"
                    },
                    "eventType": {
                        "description": "A list of strings of event types.\nValid options are: `alias`, `group`, `identify`, `page`, `screen`, and `track`.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventType"
                    },
                    "appVersion": {
                        "description": "A list of strings of app versions.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "appVersion"
                    },
                    "subscriptionId": {
                        "description": "A list of strings of subscription IDs for Actions Destinations.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "subscriptionId"
                    },
                    "activationId": {
                        "description": "A list of strings of event context IDs from a Linked Audience mapping/activation.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "activationId"
                    },
                    "audienceId": {
                        "description": "A list of strings of audience IDs for a Linked Audience.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "audienceId"
                    },
                    "spaceId": {
                        "description": "A list of strings of space IDs for a Linked Audience.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "spaceId"
                    }
                },
                "additionalProperties": false
            },
            "pagination": {
                "description": "Params to specify the page cursor and count.\n\nThis parameter exists in beta.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId",
            "destinationConfigId",
            "startTime",
            "endTime",
            "granularity"
        ]
    }
  },
  // Tool: getFilteredAtSourceMetricsFromDeliveryOverview (GET /delivery-overview/filtered-at-source)
  {
    name: "getFilteredAtSourceMetricsFromDeliveryOverview",
    description: `Get events that were filtered at Source.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "description": "The sourceId for the Workspace.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "sourceId"
            },
            "startTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nbeginning of the requested time frame, inclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nend of the requested time frame, noninclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "endTime"
            },
            "groupBy": {
                "description": "A comma-delimited list of strings representing one or more dimensions\nto group the result by.  Valid options are:\n`event Name`, `event Type`, `discard Reason`, and `app Version`.\n\nThis parameter exists in beta.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "groupBy"
            },
            "granularity": {
                "description": "The size of each bucket in the requested window.\n\nBased on the granularity chosen, there are restrictions on the time range you can query:\n\n**Minute**:\n- Max time range: 4 hours\n- Oldest possible start time: 48 hours in the past\n\n**Hour**:\n- Max Time range: 14 days\n- Oldest possible start time: 30 days in the past\n\n**Day**:\n- Max time range: 30 days\n- Oldest possible start time: 30 days in the past\n\nThis parameter exists in beta.",
                "enum": [
                    "DAY",
                    "HOUR",
                    "MINUTE"
                ],
                "type": "string",
                "title": "granularity"
            },
            "filter": {
                "description": "An optional filter for `event Name`, `event Type`, `discard Reason`, and/or `app Version` that can be applied in addition to a `group By`.\n\nThis parameter exists in beta.",
                "title": "DeliveryOverviewSourceFilterBy",
                "type": "object",
                "properties": {
                    "discardReason": {
                        "description": "A list of strings of discard reasons.\n\nSee [Discard Record Documentation](https://segment.com/docs/connections/delivery-overview/#troubleshooting) for valid error codes.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "discardReason"
                    },
                    "eventName": {
                        "description": "A list of strings of event names.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventName"
                    },
                    "eventType": {
                        "description": "A list of strings of event types.\nValid options are: `alias`, `group`, `identify`, `page`, `screen`, and `track`.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventType"
                    },
                    "appVersion": {
                        "description": "A list of strings of app versions.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "appVersion"
                    }
                },
                "additionalProperties": false
            },
            "pagination": {
                "description": "Optional params to specify the page cursor and count.\n\nThis parameter exists in beta.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId",
            "startTime",
            "endTime",
            "granularity"
        ]
    }
  },
  // Tool: getFilterInDestination (GET /destination/{destinationId}/filters/{filterId})
  {
    name: "getFilterInDestination",
    description: `Gets a Destination filter by id.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "filterId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "destinationId",
            "filterId"
        ]
    }
  },
  // Tool: removeFilterFromDestination (DELETE /destination/{destinationId}/filters/{filterId})
  {
    name: "removeFilterFromDestination",
    description: `Deletes a Destination filter.



• When called, this endpoint may generate the \`Destination Filter Deleted\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "filterId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "destinationId",
            "filterId"
        ]
    }
  },
  // Tool: updateFilterForDestination (PATCH /destination/{destinationId}/filters/{filterId})
  {
    name: "updateFilterForDestination",
    description: `Updates a filter in a Destination.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Destination Filter Enabled
* Destination Filter Disabled
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "filterId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Input for UpdateDestinationFilterV1.",
                "title": "UpdateFilterForDestinationV1Input",
                "type": "object",
                "properties": {
                    "if": {
                        "description": "The FQL if condition to update.",
                        "type": "string",
                        "title": "if"
                    },
                    "actions": {
                        "description": "Actions for this Destination filter.",
                        "type": "array",
                        "items": {
                            "description": "Represents a Destination filter action.",
                            "title": "DestinationFilterActionV1",
                            "type": "object",
                            "properties": {
                                "type": {
                                    "description": "The kind of Transformation to apply to any matched properties.",
                                    "enum": [
                                        "ALLOW_PROPERTIES",
                                        "DROP",
                                        "DROP_PROPERTIES",
                                        "SAMPLE"
                                    ],
                                    "type": "string",
                                    "title": "type"
                                },
                                "fields": {
                                    "description": "A dictionary of paths to object keys that this filter applies to.\n The literal string '' represents the top level of the object.",
                                    "type": "object",
                                    "additionalProperties": true,
                                    "title": "fields"
                                },
                                "percent": {
                                    "description": "A decimal between 0 and 1 used for 'sample' type events and\ninfluences the likelihood of sampling to occur.",
                                    "type": "number",
                                    "title": "percent"
                                },
                                "path": {
                                    "description": "The JSON path to a property within a payload object from which Segment generates a deterministic\nsampling rate.",
                                    "type": "string",
                                    "title": "path"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "type"
                            ]
                        },
                        "title": "actions"
                    },
                    "title": {
                        "description": "The title to update.",
                        "type": "string",
                        "title": "title"
                    },
                    "description": {
                        "description": "The description of this filter.",
                        "type": [
                            "string",
                            "null"
                        ],
                        "title": "description"
                    },
                    "enabled": {
                        "description": "When set to true, this Destination filter is active.",
                        "type": "boolean",
                        "title": "enabled"
                    }
                },
                "additionalProperties": false
            }
        },
        "required": [
            "destinationId",
            "filterId",
            "requestBody"
        ]
    }
  },
  // Tool: getFunctionVersion (GET /functions/{functionId}/versions/{versionId})
  {
    name: "getFunctionVersion",
    description: `Gets a Function version.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "functionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "versionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "functionId",
            "versionId"
        ]
    }
  },
  // Tool: getIngressFailedMetricsFromDeliveryOverview (GET /delivery-overview/failed-on-ingest)
  {
    name: "getIngressFailedMetricsFromDeliveryOverview",
    description: `Get events that failed on ingest.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "description": "The sourceId for the Workspace.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "sourceId"
            },
            "startTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nbeginning of the requested time frame, inclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nend of the requested time frame, noninclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "endTime"
            },
            "groupBy": {
                "description": "A comma-delimited list of strings representing one or more dimensions\nto group the result by.  Valid options are:\n`event Name`, `event Type`, `discard Reason`, and/or `appVersion`.\n\nThis parameter exists in beta.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "groupBy"
            },
            "granularity": {
                "description": "The size of each bucket in the requested window.\n\nBased on the granularity chosen, there are restrictions on the time range you can query:\n\n**Minute**:\n- Max time range: 4 hours\n- Oldest possible start time: 48 hours in the past\n\n**Hour**:\n- Max Time range: 14 days\n- Oldest possible start time: 30 days in the past\n\n**Day**:\n- Max time range: 30 days\n- Oldest possible start time: 30 days in the past\n\nThis parameter exists in beta.",
                "enum": [
                    "DAY",
                    "HOUR",
                    "MINUTE"
                ],
                "type": "string",
                "title": "granularity"
            },
            "filter": {
                "description": "An optional filter for `event Name`, `event Type`, `discard Reason`, and/or `app Version` that can be applied in addition to a `group By`.\n\nThis parameter exists in beta.",
                "title": "DeliveryOverviewSourceFilterBy",
                "type": "object",
                "properties": {
                    "discardReason": {
                        "description": "A list of strings of discard reasons.\n\nSee [Discard Record Documentation](https://segment.com/docs/connections/delivery-overview/#troubleshooting) for valid error codes.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "discardReason"
                    },
                    "eventName": {
                        "description": "A list of strings of event names.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventName"
                    },
                    "eventType": {
                        "description": "A list of strings of event types.\nValid options are: `alias`, `group`, `identify`, `page`, `screen`, and `track`.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventType"
                    },
                    "appVersion": {
                        "description": "A list of strings of app versions.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "appVersion"
                    }
                },
                "additionalProperties": false
            },
            "pagination": {
                "description": "Optional params to specify the page cursor and count.\n\nThis parameter exists in beta.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId",
            "startTime",
            "endTime",
            "granularity"
        ]
    }
  },
  // Tool: getIngressSuccessMetricsFromDeliveryOverview (GET /delivery-overview/successfully-received)
  {
    name: "getIngressSuccessMetricsFromDeliveryOverview",
    description: `Get events that were successfully received by Segment.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "description": "The sourceId for the Workspace.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "sourceId"
            },
            "startTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nbeginning of the requested time frame, inclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "The ISO8601 formatted timestamp corresponding to the\nend of the requested time frame, noninclusive.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "endTime"
            },
            "groupBy": {
                "description": "A comma-delimited list of strings representing one or more dimensions\nto group the result by.  Valid options are:\n`event Name`, `event Type`, and/or `app Version`.\n\nThis parameter exists in beta.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "groupBy"
            },
            "granularity": {
                "description": "The size of each bucket in the requested window.\n\nBased on the granularity chosen, there are restrictions on the time range you can query:\n\n**Minute**:\n- Max time range: 4 hours\n- Oldest possible start time: 48 hours in the past\n\n**Hour**:\n- Max Time range: 14 days\n- Oldest possible start time: 30 days in the past\n\n**Day**:\n- Max time range: 30 days\n- Oldest possible start time: 30 days in the past\n\nThis parameter exists in beta.",
                "enum": [
                    "DAY",
                    "HOUR",
                    "MINUTE"
                ],
                "type": "string",
                "title": "granularity"
            },
            "filter": {
                "description": "An optional filter for `event Name`, `event Type`, and/or `app Version` that can be applied in addition to a `group By`.\n\nThis parameter exists in beta.",
                "title": "DeliveryOverviewSuccessfullyReceivedFilterBy",
                "type": "object",
                "properties": {
                    "eventName": {
                        "description": "A list of strings of event names.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventName"
                    },
                    "eventType": {
                        "description": "A list of strings of event types.\nValid options are: `alias`, `group`, `identify`, `page`, `screen`, and `track`.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "eventType"
                    },
                    "appVersion": {
                        "description": "A list of strings of app versions.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "appVersion"
                    }
                },
                "additionalProperties": false
            },
            "pagination": {
                "description": "Optional params to specify the page cursor and count.\n\nThis parameter exists in beta.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId",
            "startTime",
            "endTime",
            "granularity"
        ]
    }
  },
  // Tool: getLatestFromEdgeFunctions (GET /sources/{sourceId}/edge-functions/latest)
  {
    name: "getLatestFromEdgeFunctions",
    description: `Get the latest Edge Functions for your Source.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Edge Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: getReverseETLSyncStatus (GET /reverse-etl-models/{modelId}/syncs/{syncId})
  {
    name: "getReverseETLSyncStatus",
    description: `Get the sync status for a Reverse ETL sync. 
The sync status includes all detailed information about the sync - sync status, duration, details about the extract and load phase if applicable, etc.


The rate limit for this endpoint is 250 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "modelId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "syncId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "modelId",
            "syncId"
        ]
    }
  },
  // Tool: getSourceMetadata (GET /catalog/sources/{sourceMetadataId})
  {
    name: "getSourceMetadata",
    description: `Returns a Source catalog item by its id.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceMetadataId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceMetadataId"
        ]
    }
  },
  // Tool: getSourcesCatalog (GET /catalog/sources)
  {
    name: "getSourcesCatalog",
    description: `Returns a list of all available Sources in the Segment catalog.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: getSpace (GET /spaces/{spaceId})
  {
    name: "getSpace",
    description: `Returns the Space by id.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Spaces feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "spaceId"
        ]
    }
  },
  // Tool: getSubscriptionFromDestination (GET /destinations/{destinationId}/subscriptions/{id})
  {
    name: "getSubscriptionFromDestination",
    description: `Gets a Destination subscription by id.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Destination Subscriptions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "destinationId",
            "id"
        ]
    }
  },
  // Tool: removeSubscriptionFromDestination (DELETE /destinations/{destinationId}/subscriptions/{id})
  {
    name: "removeSubscriptionFromDestination",
    description: `Deletes an existing Destination subscription.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Destination Subscriptions feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 5 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "destinationId",
            "id"
        ]
    }
  },
  // Tool: updateSubscriptionForDestination (PATCH /destinations/{destinationId}/subscriptions/{id})
  {
    name: "updateSubscriptionForDestination",
    description: `Updates an existing Destination subscription.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Destination Subscriptions feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 5 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "destinationId",
            "id",
            "requestBody"
        ]
    }
  },
  // Tool: getUser (GET /users/{userId})
  {
    name: "getUser",
    description: `Returns a user given their id.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "userId"
        ]
    }
  },
  // Tool: getWarehouseMetadata (GET /catalog/warehouses/{warehouseMetadataId})
  {
    name: "getWarehouseMetadata",
    description: `Returns a Warehouse catalog item by its id.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseMetadataId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "warehouseMetadataId"
        ]
    }
  },
  // Tool: getWarehousesCatalog (GET /catalog/warehouses)
  {
    name: "getWarehousesCatalog",
    description: `Returns a list of all available Warehouses in the Segment catalog.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Optional pagination params used to filter the Warehouses catalog.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: getWorkspace (GET /)
  {
    name: "getWorkspace",
    description: `Returns the Workspace associated with the token used to access this resource.`,
    inputSchema:     {
        "type": "object",
        "properties": {}
    }
  },
  // Tool: listActivationsFromAudience (GET /spaces/{spaceId}/audiences/{audienceId}/activations)
  {
    name: "listActivationsFromAudience",
    description: `Lists all Activations.


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "audienceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "workspaceId": {
                "description": "The workspace id\n\nThis parameter exists in alpha.",
                "type": "string",
                "title": "workspaceId"
            },
            "pagination": {
                "description": "Optional pagination.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "spaceId",
            "audienceId",
            "workspaceId"
        ]
    }
  },
  // Tool: listAudienceConsumersFromSpaceAndAudience (GET /spaces/{spaceId}/audiences/{id}/audience-references)
  {
    name: "listAudienceConsumersFromSpaceAndAudience",
    description: `Returns the list of consumers for the given audience.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 25 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Information about the pagination of this response.\n\n[See pagination](https://docs.segmentapis.com/tag/Pagination/#section/Pagination-parameters) for more info.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            },
            "search": {
                "description": "Optional search criteria\n\nThis parameter exists in alpha.",
                "title": "ListAudienceSearchInput",
                "type": "object",
                "properties": {
                    "type": {
                        "description": "Field to filter by.",
                        "enum": [
                            "DEFINITION",
                            "KEY",
                            "NAME"
                        ],
                        "type": "string",
                        "title": "type"
                    },
                    "query": {
                        "description": "Text to match against the selected field (max 255 characters).\nWhen searching by KEY, a prefix match is used. For all other options, a full wildcard search will be used.",
                        "type": "string",
                        "title": "query"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "query",
                    "type"
                ]
            },
            "sort": {
                "description": "Optional sort criteria\n\nThis parameter exists in alpha.",
                "title": "ListAudienceConsumersSortInput",
                "type": "object",
                "properties": {
                    "field": {
                        "description": "Field to sort by.",
                        "enum": [
                            "CREATED_AT",
                            "NAME",
                            "UPDATED_AT"
                        ],
                        "type": "string",
                        "title": "field"
                    },
                    "direction": {
                        "description": "Sort direction (ascending or descending).",
                        "enum": [
                            "ASC",
                            "DESC"
                        ],
                        "type": "string",
                        "title": "direction"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "direction",
                    "field"
                ]
            }
        },
        "required": [
            "spaceId",
            "id"
        ]
    }
  },
  // Tool: listAudienceSchedulesFromSpaceAndAudience (GET /spaces/{spaceId}/audiences/{id}/schedules)
  {
    name: "listAudienceSchedulesFromSpaceAndAudience",
    description: `Returns the list of schedules for the given audience.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Audience feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "id": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "spaceId",
            "id"
        ]
    }
  },
  // Tool: listAuditEvents (GET /audit-events)
  {
    name: "listAuditEvents",
    description: `Returns a list of Audit Trail events.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "startTime": {
                "description": "Filter response to events that happened after this time.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "Filter response to events that happened before this time.\nDefaults to the current time, or the end time from the pagination cursor.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "endTime"
            },
            "resourceId": {
                "description": "Filter response to events that affect a specific resource, for example, a single Source.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "resourceId"
            },
            "resourceType": {
                "description": "Filter response to events that affect a specific type, for example, Sources, Warehouses, and Tracking Plans.\n\nThis parameter exists in v1.",
                "type": "string",
                "title": "resourceType"
            },
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: listConnectedDestinationsFromSource (GET /sources/{sourceId}/connected-destinations)
  {
    name: "listConnectedDestinationsFromSource",
    description: `Returns a list of Destinations connected to a Source.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Required pagination params for the request.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: listConnectedSourcesFromWarehouse (GET /warehouses/{warehouseId}/connected-sources)
  {
    name: "listConnectedSourcesFromWarehouse",
    description: `Returns the list of Sources that are connected to a Warehouse.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "warehouseId"
        ]
    }
  },
  // Tool: listConnectedWarehousesFromSource (GET /sources/{sourceId}/connected-warehouses)
  {
    name: "listConnectedWarehousesFromSource",
    description: `Returns a list of Warehouses connected to a Source.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Required pagination params for the request.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: listDeliveryMetricsSummaryFromDestination (GET /destinations/{destinationId}/delivery-metrics)
  {
    name: "listDeliveryMetricsSummaryFromDestination",
    description: `Get an event delivery metrics summary from a Destination.

Based on the granularity chosen, there are restrictions on the time range you can query:

**Minute**:
- Max time range: 4 hours
- Oldest possible start time: 48 hours in the past

**Hour**:
- Max Time range: 7 days
- Oldest possible start time: 7 days in the past

**Day**:
- Max time range: 14 days
- Oldest possible start time: 14 days in the past`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "destinationId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "sourceId": {
                "description": "The id of the Source linked to the Destination.\n\nConfig API note: analogous to `parent`.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "sourceId"
            },
            "startTime": {
                "description": "Filter events that happened after this time.\n\nDefaults to:\n- 1 hour ago if granularity is `MINUTE`.\n- 7 days ago if granularity is `HOUR`.\n- 30 days ago if granularity is `DAY`.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "startTime"
            },
            "endTime": {
                "description": "Filter events that happened before this time. Defaults to now if not set.\n\nThis parameter exists in beta.",
                "type": "string",
                "title": "endTime"
            },
            "granularity": {
                "description": "The granularity to filter metrics to. Either `MINUTE`, `HOUR` or `DAY`.\n\nDefaults to `MINUTE` if not set.\n\nThis parameter exists in beta.",
                "enum": [
                    "DAY",
                    "HOUR",
                    "MINUTE"
                ],
                "type": "string",
                "title": "granularity"
            }
        },
        "required": [
            "destinationId",
            "sourceId"
        ]
    }
  },
  // Tool: listFunctionVersions (GET /functions/{functionId}/versions)
  {
    name: "listFunctionVersions",
    description: `Lists versions for a Function in a Workspace.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "functionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Pagination parameters.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "functionId"
        ]
    }
  },
  // Tool: restoreFunctionVersion (POST /functions/{functionId}/versions)
  {
    name: "restoreFunctionVersion",
    description: `Restore an old Function version as the latest version.



• In order to successfully call this endpoint, the specified Workspace needs to have the Functions feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "functionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "functionId",
            "requestBody"
        ]
    }
  },
  // Tool: listInvitesFromUserGroup (GET /groups/{userGroupId}/invites)
  {
    name: "listInvitesFromUserGroup",
    description: `Returns the emails of invitees to a user group.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Pagination for invites to the group.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "userGroupId"
        ]
    }
  },
  // Tool: listReverseETLSyncStatusesFromModelAndSubscriptionId (GET /reverse-etl-models/{modelId}/subscriptionId/{subscriptionId}/syncs)
  {
    name: "listReverseETLSyncStatusesFromModelAndSubscriptionId",
    description: `Get the sync statuses for a Reverse ETL mapping subscription. 
The sync status includes all detailed information about the sync - sync status, duration, details about the extract and load phase if applicable, etc. 
The default page count is 10, and then the next page can be fetched by passing the \`cursor\` query parameter.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "modelId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "subscriptionId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "count": {
                "description": "The number of items to retrieve in a page, between 1 and 100. Default is 10\n\nThis parameter exists in alpha.",
                "type": "number",
                "title": "count"
            },
            "cursor": {
                "description": "The page to request. Acceptable values to use are from the `current`, `next`, and `previous` keys.\n\nThis parameter exists in alpha.",
                "type": "string",
                "title": "cursor"
            }
        },
        "required": [
            "modelId",
            "subscriptionId"
        ]
    }
  },
  // Tool: listRoles (GET /roles)
  {
    name: "listRoles",
    description: `Returns a list of Roles available to apply to permissions for users and/or groups.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Pagination for roles.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: listRulesFromTrackingPlan (GET /tracking-plans/{trackingPlanId}/rules)
  {
    name: "listRulesFromTrackingPlan",
    description: `Lists Tracking Plan rules.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 200 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Pagination options.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "trackingPlanId"
        ]
    }
  },
  // Tool: replaceRulesInTrackingPlan (PUT /tracking-plans/{trackingPlanId}/rules)
  {
    name: "replaceRulesInTrackingPlan",
    description: `Replaces Tracking Plan rules.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Replaces Tracking Plan rules.",
                "title": "ReplaceRulesInTrackingPlanV1Input",
                "type": "object",
                "properties": {
                    "rules": {
                        "description": "Rules to replace.",
                        "type": "array",
                        "items": {
                            "description": "Represents a rule to add to a Tracking Plan.",
                            "title": "RuleInputV1",
                            "type": "object",
                            "properties": {
                                "type": {
                                    "description": "The type for this Tracking Plan rule.",
                                    "enum": [
                                        "COMMON",
                                        "GROUP",
                                        "IDENTIFY",
                                        "PAGE",
                                        "SCREEN",
                                        "TRACK"
                                    ],
                                    "type": "string",
                                    "title": "type"
                                },
                                "key": {
                                    "description": "Key to this rule (free-form string like 'Button clicked').",
                                    "type": "string",
                                    "title": "key"
                                },
                                "jsonSchema": {
                                    "description": "JSON Schema of this rule.",
                                    "title": "jsonSchema"
                                },
                                "version": {
                                    "description": "Version of this rule.",
                                    "type": "number",
                                    "title": "version"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "jsonSchema",
                                "type",
                                "version"
                            ]
                        },
                        "title": "rules"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "rules"
                ]
            }
        },
        "required": [
            "trackingPlanId",
            "requestBody"
        ]
    }
  },
  // Tool: removeRulesFromTrackingPlan (DELETE /tracking-plans/{trackingPlanId}/rules)
  {
    name: "removeRulesFromTrackingPlan",
    description: `Deletes Tracking Plan rules.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "rules": {
                "description": "Rules to delete.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "description": "Represents the parameters needed to identify a rule on the backend-side.",
                    "title": "RemoveRuleV1",
                    "type": "object",
                    "properties": {
                        "type": {
                            "description": "The type for this Tracking Plan rule.",
                            "enum": [
                                "COMMON",
                                "GROUP",
                                "IDENTIFY",
                                "PAGE",
                                "SCREEN",
                                "TRACK"
                            ],
                            "type": "string",
                            "title": "type"
                        },
                        "key": {
                            "description": "Key to this rule (free-form string like 'Button clicked').",
                            "type": "string",
                            "title": "key"
                        },
                        "version": {
                            "description": "Version of this rule.",
                            "type": "number",
                            "title": "version"
                        }
                    },
                    "additionalProperties": false,
                    "required": [
                        "type",
                        "version"
                    ]
                },
                "title": "rules"
            }
        },
        "required": [
            "trackingPlanId",
            "rules"
        ]
    }
  },
  // Tool: updateRulesInTrackingPlan (PATCH /tracking-plans/{trackingPlanId}/rules)
  {
    name: "updateRulesInTrackingPlan",
    description: `Updates Tracking Plan rules.



• In order to successfully call this endpoint, the specified Workspace needs to have the Protocols feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "trackingPlanId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates Tracking Plan rules. Non-existent rules are added.",
                "title": "UpdateRulesInTrackingPlanV1Input",
                "type": "object",
                "properties": {
                    "rules": {
                        "description": "Rules to update or insert.",
                        "type": "array",
                        "items": {
                            "title": "UpsertRuleV1",
                            "type": "object",
                            "properties": {
                                "newKey": {
                                    "description": "This rule's new intended key.",
                                    "type": "string",
                                    "title": "newKey"
                                },
                                "type": {
                                    "description": "The type for this Tracking Plan rule.",
                                    "enum": [
                                        "COMMON",
                                        "GROUP",
                                        "IDENTIFY",
                                        "PAGE",
                                        "SCREEN",
                                        "TRACK"
                                    ],
                                    "type": "string",
                                    "title": "type"
                                },
                                "key": {
                                    "description": "Key to this rule (free-form string like 'Button clicked').",
                                    "type": "string",
                                    "title": "key"
                                },
                                "jsonSchema": {
                                    "description": "JSON Schema of this rule.",
                                    "title": "jsonSchema"
                                },
                                "version": {
                                    "description": "Version of this rule.",
                                    "type": "number",
                                    "title": "version"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "jsonSchema",
                                "type",
                                "version"
                            ]
                        },
                        "title": "rules"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "rules"
                ]
            }
        },
        "required": [
            "trackingPlanId",
            "requestBody"
        ]
    }
  },
  // Tool: listSchemaSettingsInSource (GET /sources/{sourceId}/settings)
  {
    name: "listSchemaSettingsInSource",
    description: `Retrieves the schema configuration settings for a Source. If Protocols is not enabled for the Source, the configurations specific to Protocols will have default values.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceId"
        ]
    }
  },
  // Tool: updateSchemaSettingsInSource (PATCH /sources/{sourceId}/settings)
  {
    name: "updateSchemaSettingsInSource",
    description: `Updates the schema configuration for a Source. If Protocols is not enabled for the Source, any updates to Protocols-specific configurations will not be applied.

      Config API omitted fields:
- \`updateMask\`
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Input to update a Source's settings.",
                "title": "UpdateSchemaSettingsInSourceV1Input",
                "type": "object",
                "properties": {
                    "track": {
                        "description": "Track settings.",
                        "title": "track",
                        "allOf": [
                            {
                                "title": "TrackSourceSettingsV1",
                                "type": "object",
                                "properties": {
                                    "allowUnplannedEvents": {
                                        "description": "Enable to allow unplanned track events.\n\nConfig API note: equal to `allowUnplannedTrackEvents`.",
                                        "type": "boolean",
                                        "title": "allowUnplannedEvents"
                                    },
                                    "allowUnplannedEventProperties": {
                                        "description": "Enable to allow unplanned track event properties.\n\nConfig API note: equal to `allowUnplannedTrackEventProperties`.",
                                        "type": "boolean",
                                        "title": "allowUnplannedEventProperties"
                                    },
                                    "allowEventOnViolations": {
                                        "description": "Allow track event on violations.\n\nConfig API note: equal to `allowTrackEventOnViolations`.",
                                        "type": "boolean",
                                        "title": "allowEventOnViolations"
                                    },
                                    "allowPropertiesOnViolations": {
                                        "description": "Enable to allow track properties on violations.\n\nConfig API note: equal to `allowTrackEventPropertiesOnViolations`.",
                                        "type": "boolean",
                                        "title": "allowPropertiesOnViolations"
                                    },
                                    "commonEventOnViolations": {
                                        "description": "The common track event on violations.\n\nConfig API note: equal to `commonTrackEventOnViolations`.",
                                        "enum": [
                                            "ALLOW",
                                            "BLOCK",
                                            "OMIT_PROPERTIES"
                                        ],
                                        "type": "string",
                                        "title": "commonEventOnViolations"
                                    }
                                },
                                "additionalProperties": false
                            }
                        ]
                    },
                    "identify": {
                        "description": "Identify settings.",
                        "title": "identify",
                        "allOf": [
                            {
                                "title": "IdentifySourceSettingsV1",
                                "type": "object",
                                "properties": {
                                    "allowUnplannedTraits": {
                                        "description": "Enable to allow unplanned identify traits.\n\nConfig API note: equal to `allowUnplannedIdentifyTraits`.",
                                        "type": "boolean",
                                        "title": "allowUnplannedTraits"
                                    },
                                    "allowTraitsOnViolations": {
                                        "description": "Enable to allow identify traits on violations.\n\nConfig API note: equal to `allowIdentifyTraitsOnViolations`.",
                                        "type": "boolean",
                                        "title": "allowTraitsOnViolations"
                                    },
                                    "commonEventOnViolations": {
                                        "description": "The common identify event on violations.\n\nConfig API note: equal to `commonIdentifyEventOnViolations`.",
                                        "enum": [
                                            "ALLOW",
                                            "BLOCK",
                                            "OMIT_TRAITS"
                                        ],
                                        "type": "string",
                                        "title": "commonEventOnViolations"
                                    }
                                },
                                "additionalProperties": false
                            }
                        ]
                    },
                    "group": {
                        "description": "Group settings.",
                        "title": "group",
                        "allOf": [
                            {
                                "title": "GroupSourceSettingsV1",
                                "type": "object",
                                "properties": {
                                    "allowUnplannedTraits": {
                                        "description": "Enable to allow unplanned group traits.\n\nConfig API note: equal to `allowUnplannedGroupTraits`.",
                                        "type": "boolean",
                                        "title": "allowUnplannedTraits"
                                    },
                                    "allowTraitsOnViolations": {
                                        "description": "Enable to allow group traits on violations.\n\nConfig API note: equal to `allowGroupTraitsOnViolations`.",
                                        "type": "boolean",
                                        "title": "allowTraitsOnViolations"
                                    },
                                    "commonEventOnViolations": {
                                        "description": "The common group event on violations.\n\nConfig API note: equal to `commonGroupEventOnViolations`.",
                                        "enum": [
                                            "ALLOW",
                                            "BLOCK",
                                            "OMIT_TRAITS"
                                        ],
                                        "type": "string",
                                        "title": "commonEventOnViolations"
                                    }
                                },
                                "additionalProperties": false
                            }
                        ]
                    },
                    "forwardingViolationsTo": {
                        "description": "Source id to forward violations to.",
                        "type": "string",
                        "title": "forwardingViolationsTo"
                    },
                    "forwardingBlockedEventsTo": {
                        "description": "Source id to forward blocked events to.",
                        "type": "string",
                        "title": "forwardingBlockedEventsTo"
                    }
                },
                "additionalProperties": false
            }
        },
        "required": [
            "sourceId",
            "requestBody"
        ]
    }
  },
  // Tool: listSelectiveSyncsFromWarehouseAndSource (GET /warehouses/{warehouseId}/connected-sources/{sourceId}/selective-syncs)
  {
    name: "listSelectiveSyncsFromWarehouseAndSource",
    description: `Returns the schema for a Warehouse, including Sources, Collections, and Properties.


The rate limit for this endpoint is 2 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "warehouseId",
            "sourceId"
        ]
    }
  },
  // Tool: listSelectiveSyncsFromWarehouseAndSpace (GET /spaces/{spaceId}/profiles-warehouses/{warehouseId}/selective-syncs)
  {
    name: "listSelectiveSyncsFromWarehouseAndSpace",
    description: `Returns the schema for a Space Warehouse connection, including Collections and Properties.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "spaceId",
            "warehouseId"
        ]
    }
  },
  // Tool: updateSelectiveSyncForWarehouseAndSpace (PATCH /spaces/{spaceId}/profiles-warehouses/{warehouseId}/selective-syncs)
  {
    name: "updateSelectiveSyncForWarehouseAndSpace",
    description: `Updates the schema for a Space Warehouse connection, including Collections and Properties.



• When called, this endpoint may generate the \`Profiles Sync Warehouse Modified\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "warehouseId",
            "requestBody"
        ]
    }
  },
  // Tool: listSpaces (GET /spaces)
  {
    name: "listSpaces",
    description: `List Spaces.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Spaces feature enabled. Please reach out to your customer success manager for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Pagination params\n\nThis parameter exists in alpha.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: listSuppressions (GET /suppressions)
  {
    name: "listSuppressions",
    description: `Lists all suppressions in a given Workspace.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "pagination": {
                "description": "Pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        }
    }
  },
  // Tool: listSyncsFromWarehouse (GET /warehouses/{warehouseId}/syncs)
  {
    name: "listSyncsFromWarehouse",
    description: `Returns the overview of syncs for every Source connected to a Warehouse.


The rate limit for this endpoint is 2 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "warehouseId"
        ]
    }
  },
  // Tool: listSyncsFromWarehouseAndSource (GET /warehouses/{warehouseId}/connected-sources/{sourceId}/syncs)
  {
    name: "listSyncsFromWarehouseAndSource",
    description: `Returns the overview of syncs for a Source connected to a Warehouse.


The rate limit for this endpoint is 2 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Defines the pagination parameters.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "warehouseId",
            "sourceId"
        ]
    }
  },
  // Tool: listUserGroupsFromUser (GET /users/{userId}/groups)
  {
    name: "listUserGroupsFromUser",
    description: `Returns all groups a user belongs to.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "pagination": {
                "description": "Pagination for groups.\n\nThis parameter exists in v1.",
                "title": "PaginationInput",
                "type": "object",
                "properties": {
                    "cursor": {
                        "description": "The page to request.\n\nAcceptable values to use here are in PaginationOutput objects, in the `current`, `next`, and `previous` keys.\n\nConsumers of the API must treat this value as opaque.",
                        "type": "string",
                        "title": "cursor"
                    },
                    "count": {
                        "description": "The number of items to retrieve in a page, between 1 and 1000.",
                        "type": "number",
                        "title": "count"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "count"
                ]
            }
        },
        "required": [
            "userId"
        ]
    }
  },
  // Tool: previewDestinationFilter (POST /destination/filters/preview)
  {
    name: "previewDestinationFilter",
    description: `Simulates the application of a Destination filter to a provided JSON payload.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "description": "Input of the Destination filter to preview.\nFor guidance on using FQL, see the Segment documentation site.",
                "title": "PreviewDestinationFilterV1Input",
                "type": "object",
                "properties": {
                    "filter": {
                        "description": "The filter to preview.",
                        "title": "filter",
                        "allOf": [
                            {
                                "description": "A simplified Destination filter that includes the if and actions for a DestinationFilterV1.",
                                "title": "PreviewDestinationFilterV1",
                                "type": "object",
                                "properties": {
                                    "if": {
                                        "description": "A FQL statement which determines if the provided filter's actions will apply to the provided JSON payload.\nThe literal string \"all\" will result in this filter to all events.\nFor guidance on using FQL, see the Segment documentation site.",
                                        "type": "string",
                                        "title": "if"
                                    },
                                    "actions": {
                                        "description": "The filtering action to take on events that match the \"if\" statement.\nAction types must be one of: \"drop\", \"allow_properties\", \"drop_properties\" or \"sample\".",
                                        "type": "array",
                                        "items": {
                                            "description": "Represents a Destination filter action.",
                                            "title": "DestinationFilterActionV1",
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "description": "The kind of Transformation to apply to any matched properties.",
                                                    "enum": [
                                                        "ALLOW_PROPERTIES",
                                                        "DROP",
                                                        "DROP_PROPERTIES",
                                                        "SAMPLE"
                                                    ],
                                                    "type": "string",
                                                    "title": "type"
                                                },
                                                "fields": {
                                                    "description": "A dictionary of paths to object keys that this filter applies to.\n The literal string '' represents the top level of the object.",
                                                    "type": "object",
                                                    "additionalProperties": true,
                                                    "title": "fields"
                                                },
                                                "percent": {
                                                    "description": "A decimal between 0 and 1 used for 'sample' type events and\ninfluences the likelihood of sampling to occur.",
                                                    "type": "number",
                                                    "title": "percent"
                                                },
                                                "path": {
                                                    "description": "The JSON path to a property within a payload object from which Segment generates a deterministic\nsampling rate.",
                                                    "type": "string",
                                                    "title": "path"
                                                }
                                            },
                                            "additionalProperties": false,
                                            "required": [
                                                "type"
                                            ]
                                        },
                                        "title": "actions"
                                    }
                                },
                                "additionalProperties": false,
                                "required": [
                                    "actions",
                                    "if"
                                ]
                            }
                        ]
                    },
                    "payload": {
                        "description": "The JSON payload to apply the filter to.",
                        "type": "object",
                        "additionalProperties": true,
                        "title": "payload"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "filter",
                    "payload"
                ]
            }
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: removeProfilesWarehouseFromSpace (DELETE /spaces/{spaceId}/profiles-warehouses/{warehouseId})
  {
    name: "removeProfilesWarehouseFromSpace",
    description: `Deletes an existing Profiles Warehouse.



• When called, this endpoint may generate the \`Profiles Sync Warehouse Deleted\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "spaceId",
            "warehouseId"
        ]
    }
  },
  // Tool: updateProfilesWarehouseForSpaceWarehouse (PATCH /spaces/{spaceId}/profiles-warehouses/{warehouseId})
  {
    name: "updateProfilesWarehouseForSpaceWarehouse",
    description: `Updates an existing Profiles Warehouse.



• When called, this endpoint may generate the \`Profiles Sync Warehouse Updated\` event in the [audit trail](/tag/Audit-Trail).
      `,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "warehouseId",
            "requestBody"
        ]
    }
  },
  // Tool: replaceUsersInUserGroup (PUT /group/{userGroupId}/users)
  {
    name: "replaceUsersInUserGroup",
    description: `Replaces the members of a user group by email.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Subjects Added to Group
* User Added To User Group
* Group Memberships Deleted
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Replace a user group's list of users and invites with a new one.",
                "title": "ReplaceUsersInUserGroupV1Input",
                "type": "object",
                "properties": {
                    "emails": {
                        "description": "The email addresses of the users and invites to replace.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "title": "emails"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "emails"
                ]
            }
        },
        "required": [
            "userGroupId",
            "requestBody"
        ]
    }
  },
  // Tool: removeUsersFromUserGroup (DELETE /group/{userGroupId}/users)
  {
    name: "removeUsersFromUserGroup",
    description: `Removes one or multiple users or invites from a user group by email.



• When called, this endpoint may generate one or more of the following [audit trail](/tag/Audit-Trail) events:* Group Memberships Deleted
* User Removed From User Group
      


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "userGroupId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "emails": {
                "description": "The list of emails to remove from the user group.\n\nThis parameter exists in v1.",
                "type": "array",
                "items": {
                    "type": "string"
                },
                "title": "emails"
            }
        },
        "required": [
            "userGroupId",
            "emails"
        ]
    }
  },
  // Tool: removeWriteKeyFromSource (DELETE /sources/{sourceId}/writekey/{writeKey})
  {
    name: "removeWriteKeyFromSource",
    description: `Removes a Write Key from a Source.



• When called, this endpoint may generate the \`Source Modified\` event in the [audit trail](/tag/Audit-Trail).
`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "sourceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "writeKey": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            }
        },
        "required": [
            "sourceId",
            "writeKey"
        ]
    }
  },
  // Tool: replaceMessagingSubscriptionsInSpaces (PUT /spaces/{spaceId}/messaging-subscriptions)
  {
    name: "replaceMessagingSubscriptionsInSpaces",
    description: `
<div style="background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 16px; margin: 16px 0; color: #856404; display: flex; align-items: center; gap: 12px; line-height: 1.5;">
  <span style="color: #ff9800; font-size: 16px; flex-shrink: 0;">⚠️</span>
  <div style="line-height: 1.5;">
    <div style="font-weight: 600; font-size: 14px; margin-bottom: 6px;">
      Engage Premier features will no longer be available after December 15, 2025.
    </div>
    <div style="font-size: 13px;">
      This API will be deactivated after this date.
    </div>
  </div>
</div>
Replace Messaging Subscriptions in Spaces.

• This endpoint is in **Alpha** testing.  Please submit any feedback by sending an email to friends@segment.com.


• In order to successfully call this endpoint, the specified Workspace needs to have the Spaces feature enabled. Please reach out to your customer success manager for more information.


The rate limit for this endpoint is 60 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "spaceId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/vnd.segment.v1alpha+json)"
            }
        },
        "required": [
            "spaceId",
            "requestBody"
        ]
    }
  },
  // Tool: updateSelectiveSyncForWarehouse (PATCH /warehouses/{warehouseId}/selective-sync)
  {
    name: "updateSelectiveSyncForWarehouse",
    description: `Configures the schema for a Warehouse, including Sources, Collections, and Properties.



• When called, this endpoint may generate the \`Storage Destination Modified\` event in the [audit trail](/tag/Audit-Trail).
      


The rate limit for this endpoint is 2 requests per minute, which is lower than the default due to access pattern restrictions. Once reached, this endpoint will respond with the 429 HTTP status code with headers indicating the limit parameters. See [Rate Limiting](/#tag/Rate-Limits) for more information.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "warehouseId": {
                "type": "string",
                "minimum": 1,
                "maximum": 255
            },
            "requestBody": {
                "description": "Updates the schema for a Warehouse/sources pair.",
                "title": "UpdateSelectiveSyncForWarehouseV1Input",
                "type": "object",
                "properties": {
                    "syncOverrides": {
                        "description": "A list of sync schema overrides to apply to this Warehouse.",
                        "type": "array",
                        "items": {
                            "description": "Represents the override for a Source/collection/property? path to apply to a Warehouse.",
                            "title": "WarehouseSyncOverrideV1",
                            "type": "object",
                            "properties": {
                                "sourceId": {
                                    "description": "The id of the Source this schema item applies to.",
                                    "type": "string",
                                    "title": "sourceId"
                                },
                                "collection": {
                                    "description": "The collection the schema item override applies to.",
                                    "type": "string",
                                    "title": "collection"
                                },
                                "enabled": {
                                    "description": "Enable to apply the override.",
                                    "type": "boolean",
                                    "title": "enabled"
                                },
                                "property": {
                                    "description": "A property within the collection to which the override applies.",
                                    "type": "string",
                                    "title": "property"
                                }
                            },
                            "additionalProperties": false,
                            "required": [
                                "enabled",
                                "sourceId"
                            ]
                        },
                        "title": "syncOverrides"
                    }
                },
                "additionalProperties": false,
                "required": [
                    "syncOverrides"
                ]
            }
        },
        "required": [
            "warehouseId",
            "requestBody"
        ]
    }
  },
];

// --- Request Handlers ---

// 1. List Available Tools Handler
mcpServer.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: toolsList,
  };
});

// 2. Call Tool Handler
// Corrected: Added explicit type for 'request' parameter
mcpServer.setRequestHandler(CallToolRequestSchema, async (request: CallToolRequest): Promise<CallToolResult> => {
  const { name: toolName, arguments: toolArgs } = request.params;

  const toolDefinition = toolsList.find(t => t.name === toolName);

  if (!toolDefinition) {
    console.error(`Error: Received request for unknown tool: ${toolName}`);
    return { content: [{ type: "text", text: `Error: Unknown tool requested: ${toolName}` }] };
  }

  // --- Tool Execution Logic ---

  // Handler for tool: addActivationToAudience
  if (toolName === "addActivationToAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{audienceId}/{connectionId}/activations";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const audienceId_val = validatedArgs['audienceId'];
      if (typeof audienceId_val !== 'undefined' && audienceId_val !== null) { urlPath = urlPath.replace("{audienceId}", encodeURIComponent(String(audienceId_val))); }
      const connectionId_val = validatedArgs['connectionId'];
      if (typeof connectionId_val !== 'undefined' && connectionId_val !== null) { urlPath = urlPath.replace("{connectionId}", encodeURIComponent(String(connectionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: addConnectionFromSourceToWarehouse
  if (toolName === "addConnectionFromSourceToWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/connected-sources/{sourceId}";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeSourceConnectionFromWarehouse
  if (toolName === "removeSourceConnectionFromWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/connected-sources/{sourceId}";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: addDestinationToAudience
  if (toolName === "addDestinationToAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{audienceId}/destinations";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const audienceId_val = validatedArgs['audienceId'];
      if (typeof audienceId_val !== 'undefined' && audienceId_val !== null) { urlPath = urlPath.replace("{audienceId}", encodeURIComponent(String(audienceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: replaceLabelsInSource
  if (toolName === "replaceLabelsInSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/labels";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PUT",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: addLabelsToSource
  if (toolName === "addLabelsToSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/labels";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: replacePermissionsForUser
  if (toolName === "replacePermissionsForUser") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/users/{userId}/permissions";
      const userId_val = validatedArgs['userId'];
      if (typeof userId_val !== 'undefined' && userId_val !== null) { urlPath = urlPath.replace("{userId}", encodeURIComponent(String(userId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PUT",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: addPermissionsToUser
  if (toolName === "addPermissionsToUser") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/users/{userId}/permissions";
      const userId_val = validatedArgs['userId'];
      if (typeof userId_val !== 'undefined' && userId_val !== null) { urlPath = urlPath.replace("{userId}", encodeURIComponent(String(userId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: replacePermissionsForUserGroup
  if (toolName === "replacePermissionsForUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups/{userGroupId}/permissions";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PUT",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: addPermissionsToUserGroup
  if (toolName === "addPermissionsToUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups/{userGroupId}/permissions";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSourcesFromTrackingPlan
  if (toolName === "listSourcesFromTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}/sources";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: addSourceToTrackingPlan
  if (toolName === "addSourceToTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}/sources";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeSourceFromTrackingPlan
  if (toolName === "removeSourceFromTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}/sources";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listUsersFromUserGroup
  if (toolName === "listUsersFromUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups/{userGroupId}/users";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: addUsersToUserGroup
  if (toolName === "addUsersToUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups/{userGroupId}/users";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: batchQueryMessagingSubscriptionsForSpace
  if (toolName === "batchQueryMessagingSubscriptionsForSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/messaging-subscriptions/batch";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: cancelReverseETLSyncForModel
  if (toolName === "cancelReverseETLSyncForModel") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-models/{modelId}/syncs/{syncId}/cancel";
      const modelId_val = validatedArgs['modelId'];
      if (typeof modelId_val !== 'undefined' && modelId_val !== null) { urlPath = urlPath.replace("{modelId}", encodeURIComponent(String(modelId_val))); }
      const syncId_val = validatedArgs['syncId'];
      if (typeof syncId_val !== 'undefined' && syncId_val !== null) { urlPath = urlPath.replace("{syncId}", encodeURIComponent(String(syncId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listAudiences
  if (toolName === "listAudiences") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const search_val = validatedArgs['search'];
      if (typeof search_val !== 'undefined' && search_val !== null) queryParams['search'] = search_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createAudience
  if (toolName === "createAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createAudiencePreview
  if (toolName === "createAudiencePreview") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/previews";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createCloudSourceRegulation
  if (toolName === "createCloudSourceRegulation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/regulations/cloudsources/{sourceId}";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listComputedTraits
  if (toolName === "listComputedTraits") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/computed-traits";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createComputedTrait
  if (toolName === "createComputedTrait") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/computed-traits";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createDbtModelSyncTrigger
  if (toolName === "createDbtModelSyncTrigger") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/dbt-model-syncs/trigger";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1beta+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listDestinations
  if (toolName === "listDestinations") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createDestination
  if (toolName === "createDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSubscriptionsFromDestination
  if (toolName === "listSubscriptionsFromDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}/subscriptions";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createDestinationSubscription
  if (toolName === "createDestinationSubscription") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}/subscriptions";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createDownload
  if (toolName === "createDownload") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/customer-insights/download";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createEdgeFunctions
  if (toolName === "createEdgeFunctions") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/edge-functions";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listFiltersFromDestination
  if (toolName === "listFiltersFromDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destination/{destinationId}/filters";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createFilterForDestination
  if (toolName === "createFilterForDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destination/{destinationId}/filters";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listFiltersForSpace
  if (toolName === "listFiltersForSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/filters";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const integrationId_val = validatedArgs['integrationId'];
      if (typeof integrationId_val !== 'undefined' && integrationId_val !== null) queryParams['integrationId'] = integrationId_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createFilterForSpace
  if (toolName === "createFilterForSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/filters";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1beta+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listFunctions
  if (toolName === "listFunctions") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;
      const resourceType_val = validatedArgs['resourceType'];
      if (typeof resourceType_val !== 'undefined' && resourceType_val !== null) queryParams['resourceType'] = resourceType_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createFunction
  if (toolName === "createFunction") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createFunctionDeployment
  if (toolName === "createFunctionDeployment") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions/{functionId}/deploy";
      const functionId_val = validatedArgs['functionId'];
      if (typeof functionId_val !== 'undefined' && functionId_val !== null) { urlPath = urlPath.replace("{functionId}", encodeURIComponent(String(functionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listInsertFunctionInstances
  if (toolName === "listInsertFunctionInstances") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/insert-function-instances";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;
      const functionId_val = validatedArgs['functionId'];
      if (typeof functionId_val !== 'undefined' && functionId_val !== null) queryParams['functionId'] = functionId_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createInsertFunctionInstance
  if (toolName === "createInsertFunctionInstance") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/insert-function-instances";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listInvites
  if (toolName === "listInvites") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/invites";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createInvites
  if (toolName === "createInvites") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/invites";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteInvites
  if (toolName === "deleteInvites") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/invites";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const emails_val = validatedArgs['emails'];
      if (typeof emails_val !== 'undefined' && emails_val !== null) queryParams['emails'] = emails_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listLabels
  if (toolName === "listLabels") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/labels";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createLabel
  if (toolName === "createLabel") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/labels";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listProfilesWarehouseInSpace
  if (toolName === "listProfilesWarehouseInSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/profiles-warehouses";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createProfilesWarehouse
  if (toolName === "createProfilesWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/profiles-warehouses";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createReverseETLManualSync
  if (toolName === "createReverseETLManualSync") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-syncs";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listReverseEtlModels
  if (toolName === "listReverseEtlModels") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-models";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createReverseEtlModel
  if (toolName === "createReverseEtlModel") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-models";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSources
  if (toolName === "listSources") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createSource
  if (toolName === "createSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listRegulationsFromSource
  if (toolName === "listRegulationsFromSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/regulations/sources/{sourceId}";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const status_val = validatedArgs['status'];
      if (typeof status_val !== 'undefined' && status_val !== null) queryParams['status'] = status_val;
      const regulationTypes_val = validatedArgs['regulationTypes'];
      if (typeof regulationTypes_val !== 'undefined' && regulationTypes_val !== null) queryParams['regulationTypes'] = regulationTypes_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createSourceRegulation
  if (toolName === "createSourceRegulation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/regulations/sources/{sourceId}";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listTrackingPlans
  if (toolName === "listTrackingPlans") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const type_val = validatedArgs['type'];
      if (typeof type_val !== 'undefined' && type_val !== null) queryParams['type'] = type_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createTrackingPlan
  if (toolName === "createTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listTransformations
  if (toolName === "listTransformations") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/transformations";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createTransformation
  if (toolName === "createTransformation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/transformations";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listUserGroups
  if (toolName === "listUserGroups") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createUserGroup
  if (toolName === "createUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createValidationInWarehouse
  if (toolName === "createValidationInWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/validation";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listWarehouses
  if (toolName === "listWarehouses") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createWarehouse
  if (toolName === "createWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listWorkspaceRegulations
  if (toolName === "listWorkspaceRegulations") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/regulations";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const status_val = validatedArgs['status'];
      if (typeof status_val !== 'undefined' && status_val !== null) queryParams['status'] = status_val;
      const regulationTypes_val = validatedArgs['regulationTypes'];
      if (typeof regulationTypes_val !== 'undefined' && regulationTypes_val !== null) queryParams['regulationTypes'] = regulationTypes_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createWorkspaceRegulation
  if (toolName === "createWorkspaceRegulation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/regulations";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: createWriteKeyForSource
  if (toolName === "createWriteKeyForSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/writekey";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getDestination
  if (toolName === "getDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteDestination
  if (toolName === "deleteDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateDestination
  if (toolName === "updateDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getFilterById
  if (toolName === "getFilterById") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/filters/{id}";
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteFilterById
  if (toolName === "deleteFilterById") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/filters/{id}";
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateFilterById
  if (toolName === "updateFilterById") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/filters/{id}";
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1beta+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getFunction
  if (toolName === "getFunction") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions/{functionId}";
      const functionId_val = validatedArgs['functionId'];
      if (typeof functionId_val !== 'undefined' && functionId_val !== null) { urlPath = urlPath.replace("{functionId}", encodeURIComponent(String(functionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteFunction
  if (toolName === "deleteFunction") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions/{functionId}";
      const functionId_val = validatedArgs['functionId'];
      if (typeof functionId_val !== 'undefined' && functionId_val !== null) { urlPath = urlPath.replace("{functionId}", encodeURIComponent(String(functionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateFunction
  if (toolName === "updateFunction") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions/{functionId}";
      const functionId_val = validatedArgs['functionId'];
      if (typeof functionId_val !== 'undefined' && functionId_val !== null) { urlPath = urlPath.replace("{functionId}", encodeURIComponent(String(functionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getInsertFunctionInstance
  if (toolName === "getInsertFunctionInstance") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/insert-function-instances/{instanceId}";
      const instanceId_val = validatedArgs['instanceId'];
      if (typeof instanceId_val !== 'undefined' && instanceId_val !== null) { urlPath = urlPath.replace("{instanceId}", encodeURIComponent(String(instanceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteInsertFunctionInstance
  if (toolName === "deleteInsertFunctionInstance") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/insert-function-instances/{instanceId}";
      const instanceId_val = validatedArgs['instanceId'];
      if (typeof instanceId_val !== 'undefined' && instanceId_val !== null) { urlPath = urlPath.replace("{instanceId}", encodeURIComponent(String(instanceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateInsertFunctionInstance
  if (toolName === "updateInsertFunctionInstance") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/insert-function-instances/{instanceId}";
      const instanceId_val = validatedArgs['instanceId'];
      if (typeof instanceId_val !== 'undefined' && instanceId_val !== null) { urlPath = urlPath.replace("{instanceId}", encodeURIComponent(String(instanceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteLabel
  if (toolName === "deleteLabel") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/labels/{key}/{value}";
      const key_val = validatedArgs['key'];
      if (typeof key_val !== 'undefined' && key_val !== null) { urlPath = urlPath.replace("{key}", encodeURIComponent(String(key_val))); }
      const value_val = validatedArgs['value'];
      if (typeof value_val !== 'undefined' && value_val !== null) { urlPath = urlPath.replace("{value}", encodeURIComponent(String(value_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getRegulation
  if (toolName === "getRegulation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/regulations/{regulateId}";
      const regulateId_val = validatedArgs['regulateId'];
      if (typeof regulateId_val !== 'undefined' && regulateId_val !== null) { urlPath = urlPath.replace("{regulateId}", encodeURIComponent(String(regulateId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteRegulation
  if (toolName === "deleteRegulation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/regulations/{regulateId}";
      const regulateId_val = validatedArgs['regulateId'];
      if (typeof regulateId_val !== 'undefined' && regulateId_val !== null) { urlPath = urlPath.replace("{regulateId}", encodeURIComponent(String(regulateId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getReverseEtlModel
  if (toolName === "getReverseEtlModel") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-models/{modelId}";
      const modelId_val = validatedArgs['modelId'];
      if (typeof modelId_val !== 'undefined' && modelId_val !== null) { urlPath = urlPath.replace("{modelId}", encodeURIComponent(String(modelId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteReverseEtlModel
  if (toolName === "deleteReverseEtlModel") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-models/{modelId}";
      const modelId_val = validatedArgs['modelId'];
      if (typeof modelId_val !== 'undefined' && modelId_val !== null) { urlPath = urlPath.replace("{modelId}", encodeURIComponent(String(modelId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateReverseEtlModel
  if (toolName === "updateReverseEtlModel") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-models/{modelId}";
      const modelId_val = validatedArgs['modelId'];
      if (typeof modelId_val !== 'undefined' && modelId_val !== null) { urlPath = urlPath.replace("{modelId}", encodeURIComponent(String(modelId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getSource
  if (toolName === "getSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteSource
  if (toolName === "deleteSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateSource
  if (toolName === "updateSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getTrackingPlan
  if (toolName === "getTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteTrackingPlan
  if (toolName === "deleteTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateTrackingPlan
  if (toolName === "updateTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getTransformation
  if (toolName === "getTransformation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/transformations/{transformationId}";
      const transformationId_val = validatedArgs['transformationId'];
      if (typeof transformationId_val !== 'undefined' && transformationId_val !== null) { urlPath = urlPath.replace("{transformationId}", encodeURIComponent(String(transformationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteTransformation
  if (toolName === "deleteTransformation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/transformations/{transformationId}";
      const transformationId_val = validatedArgs['transformationId'];
      if (typeof transformationId_val !== 'undefined' && transformationId_val !== null) { urlPath = urlPath.replace("{transformationId}", encodeURIComponent(String(transformationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateTransformation
  if (toolName === "updateTransformation") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/transformations/{transformationId}";
      const transformationId_val = validatedArgs['transformationId'];
      if (typeof transformationId_val !== 'undefined' && transformationId_val !== null) { urlPath = urlPath.replace("{transformationId}", encodeURIComponent(String(transformationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getUserGroup
  if (toolName === "getUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups/{userGroupId}";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteUserGroup
  if (toolName === "deleteUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups/{userGroupId}";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateUserGroup
  if (toolName === "updateUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups/{userGroupId}";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listUsers
  if (toolName === "listUsers") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/users";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteUsers
  if (toolName === "deleteUsers") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/users";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const userIds_val = validatedArgs['userIds'];
      if (typeof userIds_val !== 'undefined' && userIds_val !== null) queryParams['userIds'] = userIds_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getWarehouse
  if (toolName === "getWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: deleteWarehouse
  if (toolName === "deleteWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateWarehouse
  if (toolName === "updateWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: disableEdgeFunctions
  if (toolName === "disableEdgeFunctions") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/edge-functions/disable";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: echo
  if (toolName === "echo") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/echo";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const message_val = validatedArgs['message'];
      if (typeof message_val !== 'undefined' && message_val !== null) queryParams['message'] = message_val;
      const delay_val = validatedArgs['delay'];
      if (typeof delay_val !== 'undefined' && delay_val !== null) queryParams['delay'] = delay_val;
      const triggerError_val = validatedArgs['triggerError'];
      if (typeof triggerError_val !== 'undefined' && triggerError_val !== null) queryParams['triggerError'] = triggerError_val;
      const triggerMultipleErrors_val = validatedArgs['triggerMultipleErrors'];
      if (typeof triggerMultipleErrors_val !== 'undefined' && triggerMultipleErrors_val !== null) queryParams['triggerMultipleErrors'] = triggerMultipleErrors_val;
      const triggerUnexpectedError_val = validatedArgs['triggerUnexpectedError'];
      if (typeof triggerUnexpectedError_val !== 'undefined' && triggerUnexpectedError_val !== null) queryParams['triggerUnexpectedError'] = triggerUnexpectedError_val;
      const statusCode_val = validatedArgs['statusCode'];
      if (typeof statusCode_val !== 'undefined' && statusCode_val !== null) queryParams['statusCode'] = statusCode_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: generateUploadURLForEdgeFunctions
  if (toolName === "generateUploadURLForEdgeFunctions") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/edge-functions/upload-url";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getActivationFromAudience
  if (toolName === "getActivationFromAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{audienceId}/activations/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const audienceId_val = validatedArgs['audienceId'];
      if (typeof audienceId_val !== 'undefined' && audienceId_val !== null) { urlPath = urlPath.replace("{audienceId}", encodeURIComponent(String(audienceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const workspaceId_val = validatedArgs['workspaceId'];
      if (typeof workspaceId_val !== 'undefined' && workspaceId_val !== null) queryParams['workspaceId'] = workspaceId_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeActivationFromAudience
  if (toolName === "removeActivationFromAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{audienceId}/activations/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const audienceId_val = validatedArgs['audienceId'];
      if (typeof audienceId_val !== 'undefined' && audienceId_val !== null) { urlPath = urlPath.replace("{audienceId}", encodeURIComponent(String(audienceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const workspaceId_val = validatedArgs['workspaceId'];
      if (typeof workspaceId_val !== 'undefined' && workspaceId_val !== null) queryParams['workspaceId'] = workspaceId_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateActivationForAudience
  if (toolName === "updateActivationForAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{audienceId}/activations/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const audienceId_val = validatedArgs['audienceId'];
      if (typeof audienceId_val !== 'undefined' && audienceId_val !== null) { urlPath = urlPath.replace("{audienceId}", encodeURIComponent(String(audienceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getAdvancedSyncScheduleFromWarehouse
  if (toolName === "getAdvancedSyncScheduleFromWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/advanced-sync-schedule";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: replaceAdvancedSyncScheduleForWarehouse
  if (toolName === "replaceAdvancedSyncScheduleForWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/advanced-sync-schedule";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PUT",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getAudience
  if (toolName === "getAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeAudienceFromSpace
  if (toolName === "removeAudienceFromSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateAudienceForSpace
  if (toolName === "updateAudienceForSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getAudiencePreview
  if (toolName === "getAudiencePreview") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/previews/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getAudienceScheduleFromSpaceAndAudience
  if (toolName === "getAudienceScheduleFromSpaceAndAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{id}/schedules/{scheduleId}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      const scheduleId_val = validatedArgs['scheduleId'];
      if (typeof scheduleId_val !== 'undefined' && scheduleId_val !== null) { urlPath = urlPath.replace("{scheduleId}", encodeURIComponent(String(scheduleId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getComputedTrait
  if (toolName === "getComputedTrait") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/computed-traits/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeComputedTraitFromSpace
  if (toolName === "removeComputedTraitFromSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/computed-traits/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateComputedTraitForSpace
  if (toolName === "updateComputedTraitForSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/computed-traits/{id}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getConnectionStateFromWarehouse
  if (toolName === "getConnectionStateFromWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/connection-state";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getDailyPerSourceAPICallsUsage
  if (toolName === "getDailyPerSourceAPICallsUsage") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/usage/api-calls/sources/daily";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const period_val = validatedArgs['period'];
      if (typeof period_val !== 'undefined' && period_val !== null) queryParams['period'] = period_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getDailyPerSourceMTUUsage
  if (toolName === "getDailyPerSourceMTUUsage") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/usage/mtu/sources/daily";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const period_val = validatedArgs['period'];
      if (typeof period_val !== 'undefined' && period_val !== null) queryParams['period'] = period_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getDailyWorkspaceAPICallsUsage
  if (toolName === "getDailyWorkspaceAPICallsUsage") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/usage/api-calls/daily";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const period_val = validatedArgs['period'];
      if (typeof period_val !== 'undefined' && period_val !== null) queryParams['period'] = period_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getDailyWorkspaceMTUUsage
  if (toolName === "getDailyWorkspaceMTUUsage") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/usage/mtu/daily";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const period_val = validatedArgs['period'];
      if (typeof period_val !== 'undefined' && period_val !== null) queryParams['period'] = period_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getDestinationMetadata
  if (toolName === "getDestinationMetadata") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/catalog/destinations/{destinationMetadataId}";
      const destinationMetadataId_val = validatedArgs['destinationMetadataId'];
      if (typeof destinationMetadataId_val !== 'undefined' && destinationMetadataId_val !== null) { urlPath = urlPath.replace("{destinationMetadataId}", encodeURIComponent(String(destinationMetadataId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getDestinationsCatalog
  if (toolName === "getDestinationsCatalog") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/catalog/destinations";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getEgressFailedMetricsFromDeliveryOverview
  if (toolName === "getEgressFailedMetricsFromDeliveryOverview") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/delivery-overview/failed-delivery";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;
      const destinationConfigId_val = validatedArgs['destinationConfigId'];
      if (typeof destinationConfigId_val !== 'undefined' && destinationConfigId_val !== null) queryParams['destinationConfigId'] = destinationConfigId_val;
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const groupBy_val = validatedArgs['groupBy'];
      if (typeof groupBy_val !== 'undefined' && groupBy_val !== null) queryParams['groupBy'] = groupBy_val;
      const granularity_val = validatedArgs['granularity'];
      if (typeof granularity_val !== 'undefined' && granularity_val !== null) queryParams['granularity'] = granularity_val;
      const filter_val = validatedArgs['filter'];
      if (typeof filter_val !== 'undefined' && filter_val !== null) queryParams['filter'] = filter_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getEgressSuccessMetricsFromDeliveryOverview
  if (toolName === "getEgressSuccessMetricsFromDeliveryOverview") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/delivery-overview/successful-delivery";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;
      const destinationConfigId_val = validatedArgs['destinationConfigId'];
      if (typeof destinationConfigId_val !== 'undefined' && destinationConfigId_val !== null) queryParams['destinationConfigId'] = destinationConfigId_val;
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const groupBy_val = validatedArgs['groupBy'];
      if (typeof groupBy_val !== 'undefined' && groupBy_val !== null) queryParams['groupBy'] = groupBy_val;
      const granularity_val = validatedArgs['granularity'];
      if (typeof granularity_val !== 'undefined' && granularity_val !== null) queryParams['granularity'] = granularity_val;
      const filter_val = validatedArgs['filter'];
      if (typeof filter_val !== 'undefined' && filter_val !== null) queryParams['filter'] = filter_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getEventsVolumeFromWorkspace
  if (toolName === "getEventsVolumeFromWorkspace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/events/volume";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const granularity_val = validatedArgs['granularity'];
      if (typeof granularity_val !== 'undefined' && granularity_val !== null) queryParams['granularity'] = granularity_val;
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const groupBy_val = validatedArgs['groupBy'];
      if (typeof groupBy_val !== 'undefined' && groupBy_val !== null) queryParams['groupBy'] = groupBy_val;
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;
      const eventName_val = validatedArgs['eventName'];
      if (typeof eventName_val !== 'undefined' && eventName_val !== null) queryParams['eventName'] = eventName_val;
      const eventType_val = validatedArgs['eventType'];
      if (typeof eventType_val !== 'undefined' && eventType_val !== null) queryParams['eventType'] = eventType_val;
      const appVersion_val = validatedArgs['appVersion'];
      if (typeof appVersion_val !== 'undefined' && appVersion_val !== null) queryParams['appVersion'] = appVersion_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getFilteredAtDestinationMetricsFromDeliveryOverview
  if (toolName === "getFilteredAtDestinationMetricsFromDeliveryOverview") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/delivery-overview/filtered-at-destination";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;
      const destinationConfigId_val = validatedArgs['destinationConfigId'];
      if (typeof destinationConfigId_val !== 'undefined' && destinationConfigId_val !== null) queryParams['destinationConfigId'] = destinationConfigId_val;
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const groupBy_val = validatedArgs['groupBy'];
      if (typeof groupBy_val !== 'undefined' && groupBy_val !== null) queryParams['groupBy'] = groupBy_val;
      const granularity_val = validatedArgs['granularity'];
      if (typeof granularity_val !== 'undefined' && granularity_val !== null) queryParams['granularity'] = granularity_val;
      const filter_val = validatedArgs['filter'];
      if (typeof filter_val !== 'undefined' && filter_val !== null) queryParams['filter'] = filter_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getFilteredAtSourceMetricsFromDeliveryOverview
  if (toolName === "getFilteredAtSourceMetricsFromDeliveryOverview") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/delivery-overview/filtered-at-source";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const groupBy_val = validatedArgs['groupBy'];
      if (typeof groupBy_val !== 'undefined' && groupBy_val !== null) queryParams['groupBy'] = groupBy_val;
      const granularity_val = validatedArgs['granularity'];
      if (typeof granularity_val !== 'undefined' && granularity_val !== null) queryParams['granularity'] = granularity_val;
      const filter_val = validatedArgs['filter'];
      if (typeof filter_val !== 'undefined' && filter_val !== null) queryParams['filter'] = filter_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getFilterInDestination
  if (toolName === "getFilterInDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destination/{destinationId}/filters/{filterId}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      const filterId_val = validatedArgs['filterId'];
      if (typeof filterId_val !== 'undefined' && filterId_val !== null) { urlPath = urlPath.replace("{filterId}", encodeURIComponent(String(filterId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeFilterFromDestination
  if (toolName === "removeFilterFromDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destination/{destinationId}/filters/{filterId}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      const filterId_val = validatedArgs['filterId'];
      if (typeof filterId_val !== 'undefined' && filterId_val !== null) { urlPath = urlPath.replace("{filterId}", encodeURIComponent(String(filterId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateFilterForDestination
  if (toolName === "updateFilterForDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destination/{destinationId}/filters/{filterId}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      const filterId_val = validatedArgs['filterId'];
      if (typeof filterId_val !== 'undefined' && filterId_val !== null) { urlPath = urlPath.replace("{filterId}", encodeURIComponent(String(filterId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getFunctionVersion
  if (toolName === "getFunctionVersion") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions/{functionId}/versions/{versionId}";
      const functionId_val = validatedArgs['functionId'];
      if (typeof functionId_val !== 'undefined' && functionId_val !== null) { urlPath = urlPath.replace("{functionId}", encodeURIComponent(String(functionId_val))); }
      const versionId_val = validatedArgs['versionId'];
      if (typeof versionId_val !== 'undefined' && versionId_val !== null) { urlPath = urlPath.replace("{versionId}", encodeURIComponent(String(versionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getIngressFailedMetricsFromDeliveryOverview
  if (toolName === "getIngressFailedMetricsFromDeliveryOverview") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/delivery-overview/failed-on-ingest";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const groupBy_val = validatedArgs['groupBy'];
      if (typeof groupBy_val !== 'undefined' && groupBy_val !== null) queryParams['groupBy'] = groupBy_val;
      const granularity_val = validatedArgs['granularity'];
      if (typeof granularity_val !== 'undefined' && granularity_val !== null) queryParams['granularity'] = granularity_val;
      const filter_val = validatedArgs['filter'];
      if (typeof filter_val !== 'undefined' && filter_val !== null) queryParams['filter'] = filter_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getIngressSuccessMetricsFromDeliveryOverview
  if (toolName === "getIngressSuccessMetricsFromDeliveryOverview") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/delivery-overview/successfully-received";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const groupBy_val = validatedArgs['groupBy'];
      if (typeof groupBy_val !== 'undefined' && groupBy_val !== null) queryParams['groupBy'] = groupBy_val;
      const granularity_val = validatedArgs['granularity'];
      if (typeof granularity_val !== 'undefined' && granularity_val !== null) queryParams['granularity'] = granularity_val;
      const filter_val = validatedArgs['filter'];
      if (typeof filter_val !== 'undefined' && filter_val !== null) queryParams['filter'] = filter_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getLatestFromEdgeFunctions
  if (toolName === "getLatestFromEdgeFunctions") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/edge-functions/latest";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getReverseETLSyncStatus
  if (toolName === "getReverseETLSyncStatus") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-models/{modelId}/syncs/{syncId}";
      const modelId_val = validatedArgs['modelId'];
      if (typeof modelId_val !== 'undefined' && modelId_val !== null) { urlPath = urlPath.replace("{modelId}", encodeURIComponent(String(modelId_val))); }
      const syncId_val = validatedArgs['syncId'];
      if (typeof syncId_val !== 'undefined' && syncId_val !== null) { urlPath = urlPath.replace("{syncId}", encodeURIComponent(String(syncId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getSourceMetadata
  if (toolName === "getSourceMetadata") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/catalog/sources/{sourceMetadataId}";
      const sourceMetadataId_val = validatedArgs['sourceMetadataId'];
      if (typeof sourceMetadataId_val !== 'undefined' && sourceMetadataId_val !== null) { urlPath = urlPath.replace("{sourceMetadataId}", encodeURIComponent(String(sourceMetadataId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getSourcesCatalog
  if (toolName === "getSourcesCatalog") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/catalog/sources";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getSpace
  if (toolName === "getSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getSubscriptionFromDestination
  if (toolName === "getSubscriptionFromDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}/subscriptions/{id}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeSubscriptionFromDestination
  if (toolName === "removeSubscriptionFromDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}/subscriptions/{id}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateSubscriptionForDestination
  if (toolName === "updateSubscriptionForDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}/subscriptions/{id}";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getUser
  if (toolName === "getUser") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/users/{userId}";
      const userId_val = validatedArgs['userId'];
      if (typeof userId_val !== 'undefined' && userId_val !== null) { urlPath = urlPath.replace("{userId}", encodeURIComponent(String(userId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getWarehouseMetadata
  if (toolName === "getWarehouseMetadata") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/catalog/warehouses/{warehouseMetadataId}";
      const warehouseMetadataId_val = validatedArgs['warehouseMetadataId'];
      if (typeof warehouseMetadataId_val !== 'undefined' && warehouseMetadataId_val !== null) { urlPath = urlPath.replace("{warehouseMetadataId}", encodeURIComponent(String(warehouseMetadataId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getWarehousesCatalog
  if (toolName === "getWarehousesCatalog") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/catalog/warehouses";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: getWorkspace
  if (toolName === "getWorkspace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listActivationsFromAudience
  if (toolName === "listActivationsFromAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{audienceId}/activations";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const audienceId_val = validatedArgs['audienceId'];
      if (typeof audienceId_val !== 'undefined' && audienceId_val !== null) { urlPath = urlPath.replace("{audienceId}", encodeURIComponent(String(audienceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const workspaceId_val = validatedArgs['workspaceId'];
      if (typeof workspaceId_val !== 'undefined' && workspaceId_val !== null) queryParams['workspaceId'] = workspaceId_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listAudienceConsumersFromSpaceAndAudience
  if (toolName === "listAudienceConsumersFromSpaceAndAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{id}/audience-references";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;
      const search_val = validatedArgs['search'];
      if (typeof search_val !== 'undefined' && search_val !== null) queryParams['search'] = search_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listAudienceSchedulesFromSpaceAndAudience
  if (toolName === "listAudienceSchedulesFromSpaceAndAudience") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/audiences/{id}/schedules";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const id_val = validatedArgs['id'];
      if (typeof id_val !== 'undefined' && id_val !== null) { urlPath = urlPath.replace("{id}", encodeURIComponent(String(id_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listAuditEvents
  if (toolName === "listAuditEvents") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/audit-events";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const resourceId_val = validatedArgs['resourceId'];
      if (typeof resourceId_val !== 'undefined' && resourceId_val !== null) queryParams['resourceId'] = resourceId_val;
      const resourceType_val = validatedArgs['resourceType'];
      if (typeof resourceType_val !== 'undefined' && resourceType_val !== null) queryParams['resourceType'] = resourceType_val;
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listConnectedDestinationsFromSource
  if (toolName === "listConnectedDestinationsFromSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/connected-destinations";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listConnectedSourcesFromWarehouse
  if (toolName === "listConnectedSourcesFromWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/connected-sources";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listConnectedWarehousesFromSource
  if (toolName === "listConnectedWarehousesFromSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/connected-warehouses";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listDeliveryMetricsSummaryFromDestination
  if (toolName === "listDeliveryMetricsSummaryFromDestination") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destinations/{destinationId}/delivery-metrics";
      const destinationId_val = validatedArgs['destinationId'];
      if (typeof destinationId_val !== 'undefined' && destinationId_val !== null) { urlPath = urlPath.replace("{destinationId}", encodeURIComponent(String(destinationId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) queryParams['sourceId'] = sourceId_val;
      const startTime_val = validatedArgs['startTime'];
      if (typeof startTime_val !== 'undefined' && startTime_val !== null) queryParams['startTime'] = startTime_val;
      const endTime_val = validatedArgs['endTime'];
      if (typeof endTime_val !== 'undefined' && endTime_val !== null) queryParams['endTime'] = endTime_val;
      const granularity_val = validatedArgs['granularity'];
      if (typeof granularity_val !== 'undefined' && granularity_val !== null) queryParams['granularity'] = granularity_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listFunctionVersions
  if (toolName === "listFunctionVersions") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions/{functionId}/versions";
      const functionId_val = validatedArgs['functionId'];
      if (typeof functionId_val !== 'undefined' && functionId_val !== null) { urlPath = urlPath.replace("{functionId}", encodeURIComponent(String(functionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: restoreFunctionVersion
  if (toolName === "restoreFunctionVersion") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/functions/{functionId}/versions";
      const functionId_val = validatedArgs['functionId'];
      if (typeof functionId_val !== 'undefined' && functionId_val !== null) { urlPath = urlPath.replace("{functionId}", encodeURIComponent(String(functionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listInvitesFromUserGroup
  if (toolName === "listInvitesFromUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/groups/{userGroupId}/invites";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listReverseETLSyncStatusesFromModelAndSubscriptionId
  if (toolName === "listReverseETLSyncStatusesFromModelAndSubscriptionId") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/reverse-etl-models/{modelId}/subscriptionId/{subscriptionId}/syncs";
      const modelId_val = validatedArgs['modelId'];
      if (typeof modelId_val !== 'undefined' && modelId_val !== null) { urlPath = urlPath.replace("{modelId}", encodeURIComponent(String(modelId_val))); }
      const subscriptionId_val = validatedArgs['subscriptionId'];
      if (typeof subscriptionId_val !== 'undefined' && subscriptionId_val !== null) { urlPath = urlPath.replace("{subscriptionId}", encodeURIComponent(String(subscriptionId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const count_val = validatedArgs['count'];
      if (typeof count_val !== 'undefined' && count_val !== null) queryParams['count'] = count_val;
      const cursor_val = validatedArgs['cursor'];
      if (typeof cursor_val !== 'undefined' && cursor_val !== null) queryParams['cursor'] = cursor_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listRoles
  if (toolName === "listRoles") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/roles";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listRulesFromTrackingPlan
  if (toolName === "listRulesFromTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}/rules";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: replaceRulesInTrackingPlan
  if (toolName === "replaceRulesInTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}/rules";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PUT",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeRulesFromTrackingPlan
  if (toolName === "removeRulesFromTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}/rules";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const rules_val = validatedArgs['rules'];
      if (typeof rules_val !== 'undefined' && rules_val !== null) queryParams['rules'] = rules_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateRulesInTrackingPlan
  if (toolName === "updateRulesInTrackingPlan") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tracking-plans/{trackingPlanId}/rules";
      const trackingPlanId_val = validatedArgs['trackingPlanId'];
      if (typeof trackingPlanId_val !== 'undefined' && trackingPlanId_val !== null) { urlPath = urlPath.replace("{trackingPlanId}", encodeURIComponent(String(trackingPlanId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSchemaSettingsInSource
  if (toolName === "listSchemaSettingsInSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/settings";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateSchemaSettingsInSource
  if (toolName === "updateSchemaSettingsInSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/settings";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSelectiveSyncsFromWarehouseAndSource
  if (toolName === "listSelectiveSyncsFromWarehouseAndSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/connected-sources/{sourceId}/selective-syncs";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSelectiveSyncsFromWarehouseAndSpace
  if (toolName === "listSelectiveSyncsFromWarehouseAndSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/profiles-warehouses/{warehouseId}/selective-syncs";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateSelectiveSyncForWarehouseAndSpace
  if (toolName === "updateSelectiveSyncForWarehouseAndSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/profiles-warehouses/{warehouseId}/selective-syncs";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSpaces
  if (toolName === "listSpaces") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSuppressions
  if (toolName === "listSuppressions") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/suppressions";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSyncsFromWarehouse
  if (toolName === "listSyncsFromWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/syncs";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listSyncsFromWarehouseAndSource
  if (toolName === "listSyncsFromWarehouseAndSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/connected-sources/{sourceId}/syncs";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: listUserGroupsFromUser
  if (toolName === "listUserGroupsFromUser") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/users/{userId}/groups";
      const userId_val = validatedArgs['userId'];
      if (typeof userId_val !== 'undefined' && userId_val !== null) { urlPath = urlPath.replace("{userId}", encodeURIComponent(String(userId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const pagination_val = validatedArgs['pagination'];
      if (typeof pagination_val !== 'undefined' && pagination_val !== null) queryParams['pagination'] = pagination_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: previewDestinationFilter
  if (toolName === "previewDestinationFilter") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/destination/filters/preview";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeProfilesWarehouseFromSpace
  if (toolName === "removeProfilesWarehouseFromSpace") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/profiles-warehouses/{warehouseId}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateProfilesWarehouseForSpaceWarehouse
  if (toolName === "updateProfilesWarehouseForSpaceWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/profiles-warehouses/{warehouseId}";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: replaceUsersInUserGroup
  if (toolName === "replaceUsersInUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/group/{userGroupId}/users";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PUT",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeUsersFromUserGroup
  if (toolName === "removeUsersFromUserGroup") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/group/{userGroupId}/users";
      const userGroupId_val = validatedArgs['userGroupId'];
      if (typeof userGroupId_val !== 'undefined' && userGroupId_val !== null) { urlPath = urlPath.replace("{userGroupId}", encodeURIComponent(String(userGroupId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};
      const emails_val = validatedArgs['emails'];
      if (typeof emails_val !== 'undefined' && emails_val !== null) queryParams['emails'] = emails_val;

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: removeWriteKeyFromSource
  if (toolName === "removeWriteKeyFromSource") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/sources/{sourceId}/writekey/{writeKey}";
      const sourceId_val = validatedArgs['sourceId'];
      if (typeof sourceId_val !== 'undefined' && sourceId_val !== null) { urlPath = urlPath.replace("{sourceId}", encodeURIComponent(String(sourceId_val))); }
      const writeKey_val = validatedArgs['writeKey'];
      if (typeof writeKey_val !== 'undefined' && writeKey_val !== null) { urlPath = urlPath.replace("{writeKey}", encodeURIComponent(String(writeKey_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};

 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: urlPath,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: replaceMessagingSubscriptionsInSpaces
  if (toolName === "replaceMessagingSubscriptionsInSpaces") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/spaces/{spaceId}/messaging-subscriptions";
      const spaceId_val = validatedArgs['spaceId'];
      if (typeof spaceId_val !== 'undefined' && spaceId_val !== null) { urlPath = urlPath.replace("{spaceId}", encodeURIComponent(String(spaceId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/vnd.segment.v1alpha+json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PUT",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: updateSelectiveSyncForWarehouse
  if (toolName === "updateSelectiveSyncForWarehouse") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warehouses/{warehouseId}/selective-sync";
      const warehouseId_val = validatedArgs['warehouseId'];
      if (typeof warehouseId_val !== 'undefined' && warehouseId_val !== null) { urlPath = urlPath.replace("{warehouseId}", encodeURIComponent(String(warehouseId_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
            const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = {};
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: urlPath,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
        // Add Authentication logic here if needed
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await apiClient(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } // This generated code now includes Zod validation

  // Fallback error
  console.error(`Error: Handler logic missing for tool: ${toolName}. This indicates an issue in the generator.`);
  return { content: [{ type: "text", text: `Error: Internal server error - handler not implemented for tool: ${toolName}` }] };
});


// --- Main Execution Function (stdio) ---
async function main() {
  try {
    const stdioTransport = new StdioServerTransport();

    await mcpServer.connect(stdioTransport);
    console.error(`${SERVER_NAME} MCP Server (v${SERVER_VERSION}) running on stdio${API_BASE_URL ? `, proxying API at ${API_BASE_URL}` : ''}`);
  } catch (error) {
    console.error("Error during server startup:", error);
    process.exit(1);
  }
}

async function httpServer() {
    // Streamable HTTP transport method
    const streamableHttpTransport = new StreamableHTTPServerTransport({
        sessionIdGenerator: undefined // run stateless mode
    });
    // Create Express app
    const app = express();
    // Middleware
    app.use(bodyParser.json());

    // MCP endpoint
    app.post('/mcp', async (req, res) => {
      try {
        // Create a streamable HTTP transport for this specific request
        const streamableHttpTransport = new StreamableHTTPServerTransport({
        sessionIdGenerator: undefined, // run stateless mode
        });

        res.on("close", () => {
            console.error("Request closed")
        })

        await mcpServer.connect(streamableHttpTransport);

        await streamableHttpTransport.handleRequest(req, res, req.body);
      } catch (error) {
        console.error("Error handling MCP request:", error)
        // Header sent to comply with JSON rpc spec: https://www.jsonrpc.org/specification#error_object
        if (!res.headersSent) {
          res.status(500).json({
            jsonrpc: "2.0",
            error: {
              code: -32603,
              message: "INternal server error"
            }
          })
        }
      }
    });

    // Start Express server
    const port = process.env.PORT || 8000;
    app.listen(port, () => {
      console.log(`MCP server running on port ${port}`);
    });
}

// --- Cleanup Function ---
async function cleanup() {
    console.error("Shutting down MCP server...");
    process.exit(0);
}

// Register signal handlers
process.on('SIGINT', cleanup);
process.on('SIGTERM', cleanup);

// --- Start the Server ---
console.error('Starting stdio transport...')
main().catch((error) => {
  console.error("Fatal error in main execution:", error);
  process.exit(1);
});

 // Initialize the express server
console.error('Starting the Streamable HTTP transport...')
httpServer().catch(console.error);

// --- Helper Functions (Included in the generated server code) ---
function formatApiError(error: AxiosError): string {
    let message = 'API request failed.';
    if (error.response) {
        message = `API Error: Status ${error.response.status} (${error.response.statusText || 'Status text not available'}). `;
        const responseData = error.response.data;
        const MAX_LEN = 200;
        if (typeof responseData === 'string') {
            message += `Response: ${responseData.substring(0, MAX_LEN)}${responseData.length > MAX_LEN ? '...' : ''}`;
        } else if (responseData) {
            try {
                const jsonString = JSON.stringify(responseData);
                message += `Response: ${jsonString.substring(0, MAX_LEN)}${jsonString.length > MAX_LEN ? '...' : ''}`;
            } catch {
                message += 'Response: [Could not serialize response data]';
            }
        } else {
            message += 'No response body received.';
        }
    } else if (error.request) {
        message = 'API Network Error: No response received from the server. Check network connectivity or server availability.';
        if (error.code) message += ` (Code: ${error.code})`;
    } else {
        message = `API Request Setup Error: ${error.message}`;
    }
    return message;
}

/**
 * Attempts to dynamically generate and evaluate a Zod schema from a JSON schema.
 * WARNING: Uses eval(), which can be a security risk if the schema input is untrusted.
 * In this context, the schema originates from the generator/OpenAPI spec, reducing risk.
 * @param jsonSchema The JSON Schema object (or boolean).
 * @param toolName For error logging.
 * @returns The evaluated Zod schema object.
 * @throws If schema conversion or evaluation fails.
 */
function getZodSchemaFromJsonSchema(jsonSchema: any, toolName: string): z.ZodTypeAny {
    if (typeof jsonSchema !== 'object' || jsonSchema === null) {
        // Handle boolean schemas or invalid input
        console.warn(`Cannot generate Zod schema for non-object JSON schema for tool '${toolName}'. Input type: ${typeof jsonSchema}`)
        // Fallback to allowing any object - adjust if stricter handling is needed
        return z.object({}).passthrough();
    }
    try {
        // Note: jsonSchemaToZod may require specific configurations or adjustments
        // depending on the complexity of the JSON Schemas being converted.
        const zodSchemaString = jsonSchemaToZod(jsonSchema);

        // IMPORTANT: Using eval() to execute the generated Zod schema string.
        // This is generally discouraged due to security risks with untrusted input.
        // Ensure the JSON schemas processed here are from trusted sources (like your OpenAPI spec).
        // The 'z' variable (from imported zod) must be in scope for eval.
        const zodSchema = eval(zodSchemaString);

        if (typeof zodSchema?.parse !== 'function') {
             throw new Error('Generated Zod schema string did not evaluate to a valid Zod schema object.');
        }
        return zodSchema as z.ZodTypeAny;
    } catch (err: any) {
        console.error(`Failed to generate or evaluate Zod schema for tool '${toolName}':`, err);
        // Fallback schema in case of conversion/evaluation error
        // This allows any object, effectively skipping validation on error.
        // Consider throwing the error if validation is critical.
        return z.object({}).passthrough();
    }
}
